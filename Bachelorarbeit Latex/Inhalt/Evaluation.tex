\chapter{Evaluation}
\label{cha:Evaluation}
Zu Beginn dieser Bachelorarbeit wurden Anforderungen an das Produkt gestellt, die in diesem Kapitel überprüft werden sollen. Es wurde zwischen Muss-, Soll- und Kann-Anforderungen unterschieden, wobei die Muss-Anforderungen zwingend Teil der Umsetzung sein müssen. Die beiden anderen Varianten dienen als Erweiterung, um das Produkt aufzuwerten. Daher sollen zunächst die Muss-Anforderungen betrachtet und analysiert werden. Erst im Anschluss daran wird über die Erweiterungen gesprochen. Neben den Anforderungen sollen in diesem Kapitel auch Probleme behandelt werden, die während der Umsetzung auftraten. Abschließend wird ein durchgeführter Test beleuchtet, der einige weitere Probleme aufzeigt, die ebenfalls betrachtet werden sollen. 

\section{Muss-Anforderungen}
Die erste lautet, dass das Spielfeld nach den Regeln des Originals aufgebaut sein muss. Diese Anforderung ist erfüllt worden, da die sechseckigen Felder zufällig verteilt, den Regeln entsprechend angeordnet und die darauf liegenden Zahlen in einer vorgegeben Reihe auf diesen Feldern verteilt werden.  
Im echten Brettspiel ist das Spielfeld von Wasser umrandet, auf diese Erweiterung wurde in der Implementation verzichtet, da diese nur einen Mehrwert bietet, wenn auch gleichzeitig der Handel an Häfen implementiert würde. 

Anforderung zwei bis vier aus dem Kapitel \ref{cha:Entwurf} zum Spiel fordern das Erlauben vom Bau von Straßen, Siedlungen und Städten. All diese Objekte stehen dem Bau zur Verfügung, wie die Abbildung \ref{fig:AlleObjekte} zeigt. Die Abbildung zeigt speziell einen Spielstand bei dem bereits alle drei Objekte auf dem Spielfeld errichtet wurden. Damit sind auch diese drei Anforderungen erfüllt.

\begin{figure}[h]
	\centering
	\includegraphics[height=8cm]{Bilder/AlleObjekte.png}
	\caption{Bau von Städten, Siedlungen und Straßen (eigene Darstellung)}
	\label{fig:AlleObjekte}
\end{figure}

Die nächste Anforderung handelt von der Ermittlung eines Gewinners am Ende des Spiels. Diese wurde umgesetzt, indem jeder Spieler über eine Anzahl an Siegpunkten verfügt. Wenn diese einen bestimmten Wert (Standard: 10) erreicht haben, so gilt das Spiel als beendet und der Spieler, der diesen Wert zuerst erreicht hat, wird auf dem GameOver-Bildschirm als Gewinner ausgegeben. Außerdem ist auf diesem Bildschirm ein Button zu sehen, der den Start eines neuen Spiels ermöglicht. Im Hintergrund werden zudem alle Handlungen gestoppt und zurückgesetzt, sodass bei einem Neustart auch wirklich ein neues Spiel beginnt. Der GameOver-Bildschirm ist in Abbildung \ref{fig:GameOverScreen} zu sehen. 

\begin{figure}[h]
	\centering
	\includegraphics[height=8cm]{Bilder/GameOverScreen.png}
	\caption{Ausgabe des Gewinners auf dem Bildschirm (eigene Darstellung)}
	\label{fig:GameOverScreen}
\end{figure}

Da Siedler von Catan ein rundenbasiertes Spiel ist, muss im Spiel jedem Spieler ein Zug pro Runde zugeschrieben werden. In den Anforderungen wurde unter sechstens gefordert, dass ein solcher Zug immer mit dem Würfeln beginnt, nachdem die Ressourcen verteilt werden und anschließend soll der Spieler bauen können. Diese Anforderung wurde genau so im Spiel umgesetzt. Zunächst muss der Spieler den Würfelbutton betätigen, ansonsten kann er keine andere Aktion ausführen. Erst danach ist es ihm möglich weitere Aktionen auszuführen. Bezogen auf das Bauen, ist dies nur möglich, wenn der Baumodus durch den Spieler aktiviert wird und dies wird wiederum nur erlaubt, wenn er genügend Ressourcen für den gewählten Baumodus hat. So muss der Spieler zum Bau von Straßen beispielsweise mindestens ein Lehm und ein Holz besitzen. Diese beiden Abfragen sind relativ deutlich, doch kann auch der Fall auftreten, dass die Voraussetzungen zwar erfüllt sind, aber der Spieler dennoch keinen Bau ausführen kann. Dieser Fall kann zum Beispiel auftreten, wenn kein geeigneter Bauplatz zur Verfügung steht. Dies kann auftreten, wenn bereits alle Siedlungen zu Städten aufgewertet wurden und der Spieler dennoch den entsprechenden Modus aktiviert. In solch einem Fall,  wird keine weitere Stadt errichtet, denn der Baumodus aktiviert lediglich die Bauplätze und diese sind bereits alle gelöscht, weshalb es hier zu keinem Problem kommt. Somit ist auch diese Anforderung komplett erfüllt.

Neben den notwendigen Anforderungen, die das Spiel erst ermöglichen, gibt es auch Regeln, die zwar zum Spiel gehören, aber keine Voraussetzung zum Spielen darstellen. Eine dieser Anforderungen ist die siebte. Diese besagt, dass zwischen Städten bzw. Siedlungen mindestens zwei Straßen liegen müssen. Implementiert wurde dies, indem die direkt an eine Siedlung oder Stadt angrenzenden Bauplätze für weitere Siedlungen gelöscht werden. In der Praxis erfolgt dies, indem ein Vektor um eine Siedlung oder Stadt gelegt wird und jeder Bauplatz für Siedlungen im Umkreis entfernt wird. 
Dies löst jedoch nur einen Teil des Problems. Abgesehen von den ersten beiden Zügen darf der Spieler eine Siedlung nur an eine bereits bestehende gebaute Straße gebaut werden. Hierzu macht sich das Spiel erneut Entfernungen durch Vektoren zunutze. Denn wenn ein Baumodus aktiviert wird, aktiviert dieser nicht zwangsläufig alle Bauplätze, die nicht gelöscht wurden. Stattdessen aktiviert der entsprechende Baumodus für Straßen oder Siedlungen nur solche Plätze, die direkt an eine bereits bestehende Straße angrenzen. 
Beide Varianten kombiniert, erfüllen insgesamt die Anforderung, weil keine Bauplätze nah genug an bestehenden Siedlungen existieren und gleichzeitig Straßen sowie Siedlungen nur direkt an Straßen gebaut werden können. Zudem gilt für Städte das Gleiche wie für Siedlungen, da ein Bauplatz für eine Stadt nur dort errichtet wird, wo schon eine Siedlung steht. Dadurch wird übrigens auch die Anforderung acht erfüllt, die fordert, dass das Aufwerten von Siedlungen von Siedlungen auf Städte im Spiel enthalten sein muss. 

Die Umsetzung der letzten Muss-Anforderung stellt auch gleichzeitig die komplizierteste Implementation dar. Denn hier wird gefordert, dass das Spiel berechnet, welcher Spieler die längste Straße errichtet hat und dass dieser entsprechend mit Siegpunkten belohnt wird. Eine Straße in Siedler von Catan ist so definiert, dass einzelne aneinander liegende Straßen eine längere Straße bilden. Eine Straße aus einem Stück hat somit die Länge eins. Jedes weitere Stück der Straße, dass direkt angrenzt, erhöht die Länge um ebenfalls um eins. Nach dieser Regel ist es somit auch möglich eine Kreuzung zu errichten. Eine solche Kreuzung hat demnach die Länge von drei und nicht von zwei. Die Umsetzung dessen erscheint zunächst schwieriger als die der anderen Anforderungen zu werden, lässt sich aber mit bereits bekannten Methoden implementieren. Denn die Vektoren aus Unity sind hier wieder von Nutzen. Konkret verfügt jede Straße auf dem Spielfeld über einen Punkt im Raum, dessen Vektor zur Bestimmung der Entfernung zu anderen Straßen (wie bei den Bauplätzen) genutzt werden kann. Hierzu muss für jeden Spieler eine Prüfung aller seiner Straßen erfolgen. Im Quelltext dienen hierzu zwei Schleifen, die äußere durchläuft alle Straßen des Spielers und in der inneren wird jede Iteration geprüft, ob eine Straße im Einzugsgebiet liegt. Gleichzeitig sorgt ein rekursives Vorgehen dafür, dass diese Straße ebenfalls als Ausgangspunkt genutzt wird. Jede Rekursion wiederum liefert die Länge der Straße bis jetzt zurück. Somit ergibt die Tiefe der Rekursion die Länge einer Straße. Da durch das Durchlaufen aller Straßen zum Schluss jede Straße als Beginn genutzt wurde, ist sichergestellt, dass eine der bestimmten Längen die längste Straße beschreibt und wenn das Maximum dieser Längen nun mit dem der anderen Spieler verglichen wird, kann die längste Handelsstraße dem passenden Spieler zugewiesen werden, wodurch die Anforderung erfüllt ist. 

Aufgrund der obigen Evaluation lässt sich feststellen, dass alle Muss-Anforderungen, die gestellt wurden, erfüllt sind. Dadurch sind im folgenden Abschnitt die Soll- und Kann-Anforderungen zu bewerten. Hier war es nicht das Ziel alle zu erfüllen, sondern nur eine oder einige, um das Produkt über die Mindestanforderungen hinaus aufzuwerten. 

\section{Soll- und Kann-Anforderungen}
Die nicht erfüllten Anforderungen lassen sich schnell aussortieren. So wurde die Funktion von Ereigniskarten und das Ausspielen dieser Karten nicht implementiert. Auch der Dieb, der Ressourcen blockiert und deren Diebstahl ermöglicht, erhielt keinen Einzug ins Spiel. Zudem werden auch keine Gewinnwahrscheinlichkeiten ausgeben, auch der Handel zwischen Spielern oder mit der Bank ist nicht möglich und es dürfen auch maximal zwei Spieler gleichzeitig das Spiel spielen. Die damit ganz oder teilweise erfüllten Bedingungen belaufen sich damit auf die übrigen, die wie folgt umgesetzt wurden. 

Es ist möglich, dass reale Spieler das Spiel spielen. Hierzu muss nur eine Einstellung zu Beginn des Spiels im Startmenü vorgenommen werden. Diese ist schon so implementiert, dass auch die nächste Anforderung, die einen KI-Spieler und einen realen Spieler ermöglichen soll, erfüllt wird. Denn für Spieler 1 und Spieler 2 kann jeweils ein Haken (KI an) gesetzt werden. Ist das Kästchen ausgewählt, so wird der entsprechende Spieler durch die KI gesteuert, ansonsten muss ein menschlicher Spieler die Züge ausführen. 

Darüber hinaus gilt eine weitere Kann-Anforderung als erfüllt: Es werden initiale KIs bereitgestellt. In Abschnitt \ref{sec:InitialeKI} wird darauf näher eingegangen. Daher wird dieser Punkte hier verkürzt behandelt werden. Es bleibt lediglich zu auszusagen, dass diese KIs grundlegende Strategien verfolgen und diese auch über das Spiel hinweg gleich bleiben. So ändert die KI beispielsweise nicht ihre Strategie, wenn sie nur noch wenige Siegpunkte braucht, wobei dies natürlich durch eine Erweiterung der Fallbasis möglich wäre. Durch die Bereitstellung der initialer Fälle und der Gewichtung von Attributen sind jedoch erweiterbare KIs Teil des Produktes geworden, bei denen nun die Fallbasis ausgetauscht oder erweitert werden kann, was für intelligenteres Verhalten sorgen kann. Sie unterscheiden sich damit fundamental von denen in Abschnitt \ref{sec:InitialeKI} beschriebenen Testreaktionen der KI. 

\section{Anforderungen an die Schnittstelle}
Neben direkten Anforderungen an das Spiel an sich wurden auch spezielle an die Schnittstelle gestellt, die die Qualität weiter steigern sollen. 

Bei der ersten wird gefordert, dass die KIs ohne großen Aufwand ausgetauscht werden können müssen. Dies ist durch die fallbasierte Umsetzung der initialen KIs ermöglicht. Die Fallbasis kann einfach in der Projektdatei angepasst werden. Lediglich die Standardfälle sind durch den Quelltext abgedeckt. Hieran also beliebig angepasst und ausgetauscht werden, was die Anforderung erfüllt. 

Die zweite Anforderung sagt aus, dass die KIs in unterschiedlichen Programmiersprachen umgesetzt sein dürfen. Dieser Punkt ist kein Teil der Standardumsetzung und wurde auch nicht im Detail verfolgt. Allerdings kann er dennoch als erfüllt betrachtet werden, denn als Kommunikationsmittel wird JSON benutzt. Wenn nun zusätzlich im Quellcode des Spiels das aufgerufene Programm ausgetauscht wird, so kann auch eine andere Programmiersprache die Rolle von \textit{CBRSystem.jar} übernehmen. 

Die nächste Anforderung wurde schon beim Beschreiben der Anforderungen fürs Spiel mitbetrachtet. Da zum Start der Spiels ausgewählt werden kann, ob Mensch-Mensch, Mensch-KI oder KI-KI gegeneinander spielen,muss die Schnittstelle zwangsläufig das Antreten von zwei computergesteuerten Spielern ermöglichen. 

Die letzte Anforderung erfordert erneut den größten Erläuterungsbedarf. Diese möchte nämlich, dass die KI einem menschlichen Spieler gegenüber weder bevorteilt oder benachteiligt wird, was durchaus vorkommen könnte. Hierfür ist nämlich entscheidend, dass Mensch und Maschine die gleichen Informationen erhalten, obwohl sie nicht über die gleiche Wahrnehmung verfügen. Die KI muss also eine Situationsbeschreibung erhalten, die dem gleicht, was ein menschlicher Spieler auf dem Spielfeld sehen würde, wenn er dran ist. Außerdem ist der Zeitpunkt der Informationsübermittlung relevant, weil kein konstanter Fluss erfolgen kann, wie bei der Betrachtung eines Bildschirms durch einen Menschen. Somit sollte die KI immer dann eine neue Situationsbeschreibung erhalten, wenn sie am Zug ist und die Situation so deutlich geändert hat, dass davon auszugehen ist, dass sie andere Aktionen ausführen möchte, als sie vorher ausgewählt hat. In der Implementation wird dies umgesetzt, indem zum Beginn eines Zuges eine Anfrage, die eine Situationsbeschreibung enthält, an die KI geschickt wird. Auf diese kann sie mit einem Plan reagieren. Dieser besteht aus einer Liste von Anweisungen, die die KI ausführen möchte. Das Spiel führt die Aktionen nach und nach im Namen des Spielers aus, sofern dies möglich ist. Wenn alle Aktionen ausgeführt wurden, wird die neue Situation der KI erneut übermittelt und sie kann weitere Aktionen durchführen. Dies geschieht so lange, bis im Plan der Wunsch nach dem Beenden des Zuges auftritt. Hierdurch endet der Zug der KI sofort und der nächste Spieler ist an der Reihe. Einen Ausnahmefall stellt ein leerer Plan dar. Wenn die KI auf eine gegebene Situation keine Antwort weiß, so kann es vorkommen, dass sie eine leere Antwort sendet. Dieser Fall wurde in Abschnitt \ref{sec:Staedte} schon im Detail beschrieben. Das dort beschriebene Vorgehen gewährleistet, dass durch einen Fehler der KI, ihr Zug nicht abrupt beendet wird. Stattdessen erhält Sie erneut die Chance auf die gegebene Situation angemessen zu reagieren. Antwortet sie allerdings weiterhin unsinnig, so wird ihr Zug dennoch beendet und der nächste Spieler ist an der Reihe. 

Allgemein kann durch dieses Vorgehen die gleiche Informationsverfügbarkeit simuliert werden, die auch einem Menschen zugänglich wäre. Zwar kann der Mensch dauerhaft auf seine Rohstoffe schauen, das Spielgeschehen auf der Spielfeld im Blick behalten und seine Strategie ändern und die KI ist dazu nicht in der Lage, doch muss dies auch nicht der Fall sein. Es reicht wenn die KI ihre Handlungen bei einer Situationsänderung überdenken darf. Denn der Mensch wird seine Strategie wahrscheinlich auch nur dann überdenken, wenn sich etwas an seiner Situation ändert. Für die KI wurde dies äquivalent umgesetzt. Zu Beginn eines Zuges darf die KI ihren Zug planen und nach Ausführung des Plans eventuell einen neuen umsetzen. Hierdurch lässt sich insgesamt schließlich, dass die genannte Anforderung an die Schnittstelle erfüllt wurde und ein Grundsatz von Fairness zwischen dem menschlichen und dem computergesteuerten Spieler etabliert wurde. 

Zu den Soll- und Kann-Anforderungen an die Schnittstelle bleibt festzuhalten, dass diese im gleichen Umfang umgesetzt wurden, wie sie den umgesetzten Anforderungen an das Spiel dienen. 

Abschließend kann aufgrund der obigen Analyse die Aussage getroffen werden, dass auch für die Schnittstelle alle nötigen Anforderungen hinreichend umgesetzt wurden. Lediglich an der Verwendung anderer Programmiersprachen außer Java und C\# zur Implementierung weiterer KIs Bedarf es an mehr Aufwand. Hierbei bleibt aber dennoch zu sagen, dass es möglich ist, sofern die Schnittstelle JSON genutzt wird und das angesteuerte Programm im Quellcode des Spiels vermerkt wird.

%\section{Aufgetretene Probleme}
%Viele Softwareprojekte laufen nicht so ab, wie es zuvor geplant wurde. Häufig treten Probleme auf, die vorher nicht bedacht wurden und dann die Entwicklung verzögern oder sogar zu einer angepassten Funktionsweise führen. Dies war auch im Rahmen der Entwicklung der Software zu dieser schriftlichen Ausarbeitung der Fall. Einige Hindernisse traten auf, die zunächst einmal bewältigt werden mussten, bevor andere Funktionalitäten in Betracht gezogen wurden. In diesem Abschnitt sollen diese Probleme behandelt und auch deren Lösung kurz erläutert werden. Dabei wird selbstverständlich nicht auf jeden einzelnen Fehler eingegangen, der während der Entwicklung auftrat, aber auf alle größeren Hindernisse. Zunächst sollen solche behandelt werden, die gelöst wurden. Anschließend auch auf die, die bestehen bleiben.

\section{Behobene Probleme}

Die Integration der KI und insbesondere der Schnittstelle erwies sich aufgrund des eigenen Vorgehens als schwierig. Hier hätten rückblickend wahrscheinlich mehrere Stunden eingespart werden können. Denn zunächst konzentrierte ich mich nur auf eine laufende Version des Spiels. Es wurde völlig vernachlässigt, wie die Schnittstelle und damit auch die KIs später noch eingebunden werden können. Hierdurch entstanden vor allem konzeptionelle Hindernisse. Da das Spiel anfangs nur auf menschliche Spieler ausgelegt war, konnten diese zwar spielen, aber der eigentliche Sinn, KIs gegeneinander antreten zu lassen, rückte in den Hintergrund. Daraus resultierend wuchsen Klassen von MonoBehaviour erbend. Sie übernahmen auch Funktionalitäten, die auch in eine andere Klasse hätten ausgelagert werden können. Hier hätte sich eine höher gelagerte Klasse \textit{Spieler} angeboten. Diese hätte alle allgemeinen Eigenschaften des Spielers übernommen und in der Klasse \textit{PlayerScript} hätten lediglich Funktionen, die Unity direkt betreffen, vorhanden sein müssen. Stattdessen sind übergeordnete Funktionen jetzt auch in die PlayerScript-Klasse integriert, was während der Programmierung für kleinere Probleme sorgte. An sich bietet es jedoch auch Vorteile. So erfolgt die Verwaltung des Spielers an einer zentralen Stelle im Spiel und Änderungen an den Attributen der Entität eines Spielers durch die KI wirkt sich genau so aus, als wären die Änderungen durch einen Menschen vorgenommen worden. Dies kommt dem Aspekt der Fairness wiederum zugute. 

Insgesamt zieht sich dieses Vorgehen durch die gesamte Schnittstelle. Die Klasse \textit{PlayerScript} dient hierbei nur als größtes Beispiel. Andere Fälle in denen dieses Vorgehen deutlich wird, sind die abstrakten Bauplätze, die teilweise direkt in den Entitäten des Spiels erzeugt werden, um sie dann an die KI zu schicken. Auch dies scheint konzeptionell fragwürdig, liefert aber eine enge Verzahnung beider Spielmodi (Mensch vs. KI). 

Durch eine längere bzw. bessere Konzeptionsphase hätte ich das ungewollte auftreten solcher Verzahnungen wohl möglich verhindern oder zumindest den Einsatz auf gewollte Male beschränken können. Wie groß der Einfluss auf die Dauer des Projektes im Endeffekt genau war, lässt sich nur schwer beziffern. Auf der einen Seite ist der Quellcode auf diese Weise möglicherweise schlechter nachzuvollziehen, was bei Änderungen zu einer Verzögerung führen kann. Andererseits hätte die Konzeption auch mehr Zeit in Anspruch nehmen müssen. Diese beiden Aspekte gilt es also gegeneinander abzuwägen. Langfristig kann jedoch ausgesagt werden, dass dann ein Zeitersparnis durch die Konzeption entsteht.

Auch die Implementierung von Testreaktionen hätte besser konzipiert werden können und hängt eng mit dem obigen Aspekt zusammen. Damit die KI sinnvoll agieren kann, muss zunächst einmal eine geeignete Situationsbeschreibung erstellt werden, die dann mittels JSON über die Schnittstelle der KI zugänglich gemacht wird. Durch das Implementieren der Schnittstelle, nachdem bereits eine laufende Version für menschliche Spieler erstellt wurde, erwies sich auch das als Hindernis. Zur Lösung wurde zusätzlich zu jedem relevanten Unity-Objekt eine abstrakte Darstellung in Form einer Klasse erzeugt, die alle relevanten Informationen enthält. Die Zusammenfassung dieser Klassen in Form der Klasse \textit{Situation} ermöglichte schließlich eine geeignete Übermittlung der Daten, sodass die KI antworten kann. 

Zu diesem Zeitpunkt unterstützte die KI jedoch noch keine wirklich intelligente Verwaltung von Wissen. Stattdessen musste im Quellcode mittels Verzweigungen festgehalten werden, wie auf bestimmte Eigenschaften einer Situation reagiert wird. Dies vereinfachte das Testen des Spiels und half dabei, die Schnittstelle richtig zu konfigurieren. Dennoch erschwerte dies das Einführen der fertigen bzw. initialen KI. Diese arbeitet fallbasiert mit dem MyCBR zusammen und hierfür mussten wieder fundamentale Änderungen am Quellcode vorgenommen werden. Die Anpassungen an der Schnittstelle waren minimal. Lediglich die Java-Klasse \textit{CBRSystem} musste etwas umgebaut werden. Doch war die Überführung der Situation in Form einer Klasse in Fälle, die die Fallbasis versteht, relativ aufwendig. Außerdem änderte ich die Fallbasis zur Erhöhung der Intelligenz der KI dauerhaft. Auch dies war mit hohem Anpassungsaufwand verbunden. 

Rückblickend würde ich auch dies anders lösen. Ich würde zunächst genau festlegen, welche Reaktionen eine initiale KI zeigen soll und dann Fälle definieren, mit denen diese Reaktionen erreicht werden kann. Somit würde die Implementation von Testreaktionen ohne Fallbasis wegfallen und es wäre mehr Zeit zur Verbesserung der initialen KIs geblieben. Kombinieren würde ich dieses Vorgehen mit dem oben beschriebenen Punkt, der besagt, dass mehr Zeit auf die Konzeption hätte verwendet werden sollen. Dann wäre das Spiel zwar langsamer und mit zunächst weniger Features, aber dafür insgesamt schneller entstanden und die weitere Funktionalitäten hätten mit weniger Aufwand Einzug ins Spiel erhalten können. 

Das Stoppen des Spiels war bevor die KIs eingeführt werden auch kein Problem. Der Gamemanager wurde disabled, was automatisch dazu führte, dass das Spiel nicht weitergeführt werden konnte. Die Anfrage durch das Spiel an die Schnittstelle erfolgt allerdings unabhängig von der Update-Methode des Gamemanagers, was zu einem Fortführen des Spiels führt, selbst wenn schon der \textit{Game Over Screen} angezeigt wird. Um dieses Problem zu beheben wurde, vor dem Starten einer Anfrage an die KI getestet, ob nicht schon ein Spieler gewonnen hat. Sollte dies der Fall sein, wird keiner weitere Anfrage gesendet und das Spiel stoppt. Eigentlich handelt es sich hierbei mehr um einen einfachen Bug, als um ein Problem, das die Umsetzung betrifft. Allerdings geht es in die gleiche Richtung wie die oben aufgeführten und wird daher auch in diesem Zusammenhang behandelt. 

Das Vorherbestimmen der Antworten der fertigen KI erwies sich als weiteres Problem. Hierbei wurden zwar Standardfälle in die Fallbasis eingefügt, die für ein bestimmtes Verhalten der KIs sorgen sollten. Die KIs verhielten sich allerdings nicht immer wie erwartet. Sodass schließlich einige Einschränkungen in das Retrieval eingeführt und eine Erweiterung der Fallbasis vorgenommen werden musste. 

Ein Beispiel für einen solchen Fall ist das Einbeziehen des vorherigen Plans der KI in die aktuelle Entscheidung. Dies wäre nötig, wenn Bauplätze für Siedlungen aktiviert werden sollen. Es kann vorkommen, dass die KI den Plan, Bauplätze zu aktivieren entsendet, aber keiner aktiviert wird. Dann hätte sich die Situation für die KI nicht geändert und sie würde diesen Plan immer wieder entsenden. In der Implementation wird dieses Problem nun gelöst, indem der vorherige Plan zwischengespeichert wird und mit dem aktuellen abgeglichen wird. Somit kann ein Fehlverhalten verhindert und ein alternatives Vorgehen in die KI integriert werden. Allerdings wäre es angebracht auch dies fallbasiert zu lösen. Hierzu wird die Situation an sich verändert. Hierfür musste pro Aktivierungsaktion eine Methode zur Verfügung gestellt werden, die einbezieht, ob es überhaupt aktivierbare Plätze gibt. Diese Information wird in Form eines weiteren Symptoms in den Fällen gespeichert. Konkret handelt es sich dabei um drei Symptome, die mit Wahrheitswerten zu füllen sind, pro Bauplatzart einer.

Am simpelsten ist die Überprüfung von Städtebauplätzen. Hierfür prüft die entsprechende Methode lediglich, ob der aktuelle Spieler über Siedlungen verfügt, denn jede Siedlung ist auch gleichzeitig ein Bauplatz für eine Stadt. Wenn also unausgebaute Siedlungen auf dem Spielfeld vorhanden sind, so können auch Städtebauplätze aktiviert werden. 

Schwieriger gestaltet sich die Überprüfung für Straßen und Siedlungen. Hierfür muss das Spiel diese Information direkt mit in die Situation einfügen. Hierzu wurde eine Methode gestaltet, die eine normale Aktivierung der Plätze simuliert und speichert, wie viele Aktivierungen vorgenommen wurden. Im Fall von null Aktivierungen würde ein \textit{false} ansonsten ein \textit{true} übermittelt werden. Dies ist für Straßen und Siedlungen äquivalent einsetzbar. Zu beachten ist, dass hierdurch das Spiel eine erbringt, die eigentlich durch die KI selber erbracht werden müsste. Schließlich muss ein menschlicher Spieler auch selbst feststellen, dass ein erneutes Drücken des Buttons zum Aktivieren von Bauplätzen unsinnig ist, wenn beim ersten Versuch, schon keine Plätze aktiviert wurden. Der Grundsatz der Fairness könnte hierdurch zwar als verletzt betrachtet werden jedoch nur theoretisch. In der Praxis ist das Erkennen der gleichen Handlung als unsinnig so grundlegend, dass die KI dadurch nicht bevorteilt wird. 

Abschließend bleibt zu den behobenen Problemen zu sagen, dass diese zwar einen Einfluss auf die Umsetzung des Projektes hatten und durch eine bessere Konzeption möglicherweise Zeit hätte gespart werden können. Jedoch hielten die aufgeführten Hindernisse das Fortschreiten der Entwicklung nicht solch einem Ausmaß zurück, dass der Erfolg der Implementierung zu einem Zeitpunkt gefährdet gewesen wäre. Denn an sich wurde viel Zeit in die Konzeption gesteckt, was im Kapitel \ref{cha:Entwurf} Entwurf nachzulesen ist. In der tatsächlichen Umsetzung mussten dann aber Anpassungen vorgenommen werden, die einige Aspekte des Entwurfs hinfällig machten. Eventuell wäre es daher eine Option gewesen, wenn deutlich wird, dass ein Aspekt nicht so umgesetzt werden kann, zurück zum Entwurf zu gehen und diesen zu überarbeiten. Hierdurch hätten die genannten unerwünschten Effekte vermieden werden können. 

\section{Tests}
\label{sec:Tests}
Zur genaueren Evaluierung der Software wurden 20 Testspiele durchgeführt, bei denen jeweils beide Spieler KI-Spieler waren. Die angewendeten Strategien sind unter Abschnitt \ref{sec:InitialeKI} nachzulesen. Genau genommen, versucht Spieler eins Ressourcen zu gewinnen, um Städte zu bauen und Spieler 2 konzentriert sich auf nötige Ressourcen für Siedlungen und Straßen. 

Nach 20 Spielen hatte Spieler 1 sechs Siege zu verzeichnen, Spieler 2 sieben und bei weiteren sieben Spielen kam es zu keiner finalen Entscheidung, weil die Spieler entweder nicht alle Ressourcen erlangten oder sie sich gegenseitig so eingebaut haben, dass keiner mehr den Sieg erlangen konnte. Eine Visualisierung der Ergebnisse ist in Abb. \ref{fig:Ergebnisse} zu sehen. 

\begin{figure}[h]
	\centering
	\includegraphics[height=9cm]{Bilder/Testergebnisse.png}
	\caption{Säulendiagramm zu den Testergebnissen (eigene Darstellung)}
	\label{fig:Ergebnisse}
\end{figure}

Mithilfe dieser Ergebnisse lassen sich Probleme identifizieren, die noch nicht behoben wurden und einen Grundstein für spätere Verbesserungen legen. 

\textbf{Die Strategien sorgten für keinen signifikanten Unterschied im Ergebnis:}\\
Da Spieler 1 sechs mal gewann und Spieler 2 sieben der 20 Spiele, scheint die Strategie keinen oder zumindest keinen großen Einfluss auf das Ergebnis zu haben. Möglicherweise sind beide Strategien ungefähr gleich gut oder das Präferieren eines Rohstoffs wirkt sich nicht allzu stark aus. 
\\\\
\textbf{Spieler erlangen nicht immer alle nötigen Ressourcen:}\\
Von den gespielten 20 Spielen konnten ganze sieben nicht zu Ende gespielt werden, weil keiner mehr eine Chance auf den Sieg hatte. Bei sechs dieser Spiele war der Grund. dass zu Beginn des Spiels keiner der Spieler Zugang zu allen nötigen Ressourcen erlangte. Ohne die Möglichkeit zum Handeln muss jeder Spieler seine ersten beiden Siedlungen so platzieren, dass er mindestens Zugang zu Lehm, Holz, Schafen und Getreide hat. Diese Ressourcen sind nötig, um neue Siedlungen bauen zu können und ohne diese ist kein Sieg möglich. 
\\\\
\textbf{Der Wüstenbug trat auf:}\\
In ca. einem von 19 Fällen wird die Mitte des Spielfelds als Wüste gewählt, wenn dies geschieht, wird ein leeres Prefab für Nummern dort platziert. Dies sollte nicht vorkommen, beeinflusst das Spielgeschehen an sich jedoch nicht. 
\\\\
\textbf{Spieler können sich gegenseitig einbauen:}\\
Der übrige Fall, der für ein Spiel ohne Sieger sorgte, ist durch gegenseitiges Einbauen zu erklären. Es kann vorkommen, dass einer oder beide Spieler vermehrt Straßen bauen, weil andere Ressourcen Ihnen gerade nicht zur Verfügung stehen. Dadurch wird in einigen Spielen, dass gesamte Spielfeld durch Straßen belegt und es bleibt kein freier Platz. Die aktuellen KIs Wissen nicht, wie auf eine solche Situation zu reagieren ist und stellen das Handeln ein. Dies führt dazu, dass ein Spiel, welches theoretisch noch beendet werden könnte, aufgrund der Intelligenz der KI keinen Sieger findet.

Abschließend bleibt zu den identifizierten Problemen zu sagen, dass innerhalb der 20 Spiele keine Situation auftrat, auf die die Spieler anders als erwartet reagierten. Es kam demnach nicht zu Fehlern, die einen Spielabbruch zur Folge gehabt hätten. Hierdurch kann nun zumindest vermutet werden, dass die Software sicher läuft und für eine Einhaltung der geltenden Spielregeln sorgt. Außerdem haben auch alle Funktionalitäten wie erwartet funktioniert. Die beschriebenen Probleme hängen hauptsächlich mit der Intelligenz der KI zusammen und nicht mit dem Spiel an sich. 






