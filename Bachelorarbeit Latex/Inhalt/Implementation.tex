\chapter{Implementation}
\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}


\lstset{language=[Sharp]C,
	captionpos=b,
	%numbers=left, %Nummerierung
	%numberstyle=\tiny, % kleine Zeilennummern
	frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
	showspaces=false,
	showtabs=false,
	breaklines=true,
	showstringspaces=false,
	breakatwhitespace=true,
	escapeinside={(*@}{@*)},
	commentstyle=\color{greencomments},
	morekeywords={partial, var, value, get, set},
	keywordstyle=\color{bluekeywords},
	stringstyle=\color{redstrings},
	basicstyle=\ttfamily\small,
}

Dieses Kapitel soll sich mit der Umsetzung der im Entwurf beschriebenen Software befassen. Es werden das Spiel, die Schnittstelle und die initialen KI-Spieler erläutert, wobei chronologisch vorgegangen wird, sodass  zunächst eine grundlegende Version des Spiels beschrieben und anschließend auf die Umsetzung der Schnittstelle eingegangen wird. Anschließend wird die Weiterentwicklung des Spiels und seiner anderen Bestandteile fokussiert. Die Implementation der initialen KIs wird zuletzt betrachtet. \\
Nach der Erläuterung der Implementation werden Anpassungen beschrieben, die zuvor zwar nicht so geplant wurden,  während der Umsetzung jedoch trotzdem Einzug ins Programm erhielten bzw. ausgelassen wurden.

\section{Verwendete Technologien}
\label{sec:Technologien}
Zu Beginn des Kapitels \ref{cha:Entwurf} wird bereits thematisiert, dass für die Erstellung der Software \textit{Unity}, \textit{C\#} und \textit{JSON} für die Schnittstelle verwendet werden sollen. In diesem Abschnitt soll noch einmal genauer auf die verwendeten Technologien eingegangen und die Entscheidung für diese Technologien begründet werden.

\textit{Unity} ist eine Spieleentwicklungsengine, die eine schnelle und einfache Entwicklung komplexer Spieler ermöglicht. Zur Wahl standen entweder die \textit{Unity}-Engine oder die \textit{Unreal}-Engine. Obwohl für dieses Projekt beide Optionen infrage gekommen wären, fiel die Entscheidung auf \textit{Unity}, welches  sich vor allem durch den sehr umfangreichen \textit{Asset-Store} und somit durch die Möglichkeit, einfacher Importe vielerlei kostenloser Grafiken, Animationen und Sounds sowie  die Entwicklung beschleunigenden Funktionalitäten, aus. Außerdem ist \textit{Unity} subjektiv gesehen benutzerfreundlicher als die \textit{Unreal}-Engine.\\
Auch \textit{Unreal} bietet einige Vorteile gegenüber \textit{Unity}, die jedoch für diese Arbeit keinen nennenswerten Mehrwert bieten,  weshalb die Entscheidung im Hinblick auf die Ziele dieser Arbeit auf die Verwendung von \textit{Unity} fiel, zumal der Fokus hauptsächlich auf der Logik des Spiels liegt und nicht auf den grafischen Feinheiten.

Mit der Verwendung von \textit{Unity} wurden auch die möglichen Programmiersprachen stark eingeschränkt. Bis zur Version 2017.1 war es möglich neben \textit{C\#} auch in JavaScript und \textit{Boo} zu programmieren, seit der Veröffentlichung dieser Version ist \textit{C\#} jedoch die einzig verwendbare Programmiersprache. Entsprechend fiel die Wahl der Programmiersprache für dieses Projekt auf \textit{C\#}.  \\
\textit{C\#} ist eine plattformunabhängige, objektorientierte Programmiersprache, die starke Ähnlichkeiten zu \textit{Java} und \textit{C++} aufweist. Neben dem objektorientierten Paradigma ist jedoch auch funktionale oder imperative Programmierung möglich.

Die Schnittstelle soll durch \textit{JSON} (\textit{JavaScript Object Notation}) realisiert werden, womit gemeint ist, dass \textit{JSON} das gewählte Format der Informationsübertragung zwischen Spiel und KI-Spieler ist. \textit{JSON} soll durch das folgende Beispiel veranschaulicht werden:\\

\textbf{KI-Anfrage:} \\
\{\\
\null\quad \quotes{spieler}: \quotes{1} \\
\null\quad \quotes{aktion}: \quotes{Wuerfeln}\\
\}
\\
\\
\textbf{Spiel-Antwort:} \\
\{\\
\null\quad \quotes{augenzahl}: 8 \\
\null\quad \quotes{ressourcen}: [ \\
\null\quad\quad \{ \\
\null\quad\quad\quad \quotes{name}: \quotes{lehm} \\
\null\quad\quad\quad \quotes{anzahl}: 2 \\
\null\quad\quad\}, \\
\null\quad\quad \{ \\
\null\quad\quad\quad \quotes{name}: \quotes{holz} \\
\null\quad\quad\quad \quotes{anzahl}: 1 \\
\null\quad\quad\}, \\
\null\quad]\\
\}

Das Beispiel zeigt mehrere Aspekte des \textit{JSON}-Formats: zu sehen sind zwei Dateien, einerseits die gesendete Anfrage durch die KI und andererseits die Antwort des Spiels.

Aus dem Beispiel geht hervor, dass innerhalb der geschweiften Klammern Variablen definiert werden, die einen Wert enthalten. Auffällig ist insbesondere, dass nicht typisiert wird, sondern ohne Auskunft über den Variablentyp verschickt wird.

Eine Zeile, die ein Attribut beschreibt, besteht aus dem Namen der Variable in Anführungszeichen, gefolgt von einem Doppelpunkt und dem zugewiesenen Wert. Zeichenketten wie der Name eines Attributes werden in Anführungszeichen gesetzt, wohingegen Zahlen ohne dastehen. Deutlich wird dies bei den Attributen \textit{spieler} (KI-Anfrage) und \textit{augenzahl} (Spiel-Antwort). Im ersten Fall handelt es sich um einen Namen, im zweiten um eine Anzahl. 

Des Weiteren lassen sich Listen per \textit{JSON}-Format verschicken. So enthält die zweite Datei eine Liste der Ressourcen eines Spielers und schickt ihm diese als Teil der Antwort zu. Es werden nachfolgend aus Platzgründen nur zwei Ressourcen beispielhaft angegeben. Listen werden mit eckigen Klammern geöffnet und geschlossen. Innerhalb einer solchen Sektion werden einzelne Objekte durch Kommata getrennt und von geschweiften Klammern umschlossen definiert.

Ob in diesem Fall die Verwendung einer Liste nötig wird, ist fraglich, doch dieses Beispiel dient, wie erwähnt, lediglich der Veranschaulichung und muss daher nicht zwingend in gleicher Weise später implementiert werden. Weiterhin ist zu diskutieren, ob das Spiel überhaupt mit den Ressourcen eines Spielers auf das Würfeln antworten muss oder ob hierfür eine weitere Anfrage erfolgen sollte. 

\section{Die grundlegende Umsetzung des Spiels}
\label{sec:Spiel}
In Abschnitt \ref{sec:Technologien} wurde auf die Gründe der Verwendung von \textit{Unity} für die Umsetzung des Spiels eingegangen. Einer ist, dass mit verhältnismäßig geringem Aufwand eine ansprechende Nutzeroberfläche gestaltet werden kann. Die Grafiken und die Formen der Objekte, die im Spiel verwendet werden, stammen aus einer anderen Implementation von \textit{Siedler von Catan}, die auf Github unter \textit{https://github.com/buttsj/unity-settlers-of-catan} zu finden ist (\cite{Butt2016}).

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm]{Bilder/SpielfeldStartoberflaeche.png}
	\caption{Nutzeroberfläche zu Beginn des Spiels (\cite[vgl.]{Butt2016})}
	\label{fig:Nutzeroberfläche}
\end{figure}

Abbildung \ref{fig:Nutzeroberfläche} zeigt eine so gestaltete Oberfläche. Hierbei fallen mehrere Aspekte ins Auge. Zunächst einmal das Spielfeld selbst. Dieses besteht wie das Original aus insgesamt 19 sechseckigen Einzelteilen. Die Verteilung der Sechsecke erfolgt nach folgender Verfügbarkeit: viermal Wald, viermal Getreide, dreimal Ziegel, dreimal Stein, dreimal Schaf, einmal Wüste. Auffällig ist, dass das Wüstenfeld als einziges ohne Nummer bleibt, was daran liegt, dass es keine Ressourcen liefert, wenn ein Spieler eine Siedlung an diesem Feld gründet. \\
Links ist eine Art Pyramide, die eine Siedlung darstellen soll, zu sehen. Dementsprechend befindet sich im unteren rechten Bereich des Bildes das Abbild einer Straße. Neben den Objekten in der Umgebung sind im Sichtfeld des Nutzers ebenso zwei ausgegraute Buttons (Würfeln und Zug beenden) und eine Anzeige, die die verfügbaren Ressourcen des aktuellen Spielers darstellt, zu sehen. \\

\subsection{Die Generierung des Spielfelds}

\lstinputlisting[label=lst:MapGenerator1,caption={Spielfeld-Generator Startmethode}]{Listings/MapGenerator1.cs}

Listing \ref{lst:MapGenerator1} und \ref{lst:MapGenerator2} zeigen wie die Erstellung des beschriebenen Spielfelds zustande kommt. In der gezeigten Startmethode werden mehrere Listen deklariert und initialisiert. Die Liste \textit{resources} enthält Materialien - jeweils in der Anzahl, in der sie später auf dem Spielfeld vorkommen dürfen. Neben dieser Liste existieren weitere. Eine speichert beispielsweise alle Sechsecke, sodass diese später angesteuert werden können. Eine andere speichert die Materialien der Nummern auf den Sechsecken. Zudem stehen zwei Listen zur Verfügung, die Ganzzahlen speichern. Zum Ende der Startmethode wird die Liste \textit{tiles} ohne Inhalt initialisiert, bevor \textit{CreateMap(List<Material> resources, List<Material> numbers, List<GameObject> tiles, List<int> positions, List<GameObject> hexTiles, List<int> ints)} aufgerufen wird. \\

\lstinputlisting[label=lst:MapGenerator2,caption={Spielfeld-Generator CreateMap-Methode}]{Listings/MapGenerator2.cs}

Listing \ref{lst:MapGenerator2} zeigt wie die Oberfläche für jedes neue Spiel generiert wird. Zu Beginn wird eine foreach-Schleife geöffnet, die einmal für jedes in hexTiles enthaltene Sechseck (GameObject) durchlaufen wird. Innerhalb dieser Schleife wird zunächst die Oberfläche des aktuellen Sechsecks als Variable sowie die Nummer auf dem Sechseck zwischengespeichert. Daraufhin wird zufällig eine Zahl generiert, die zwischen 0 (inklusive) und der Größe der Menge an verfügbaren Landschaften liegt (exklusive). Nun kann im nächsten Schritt das Material an der Stelle dieser zufälligen Zahl der Liste \textit{resources} dem aktuellen Sechseck als Oberfläche zugeordnet werden, wie in Zeile zwölf zu sehen ist. Anschließend wird, um eine Doppelvergabe zu vermeiden, das vergebene Material aus der \textit{resources} Liste entfernt. \\
In den darauffolgenden Zeilen, wird dafür gesorgt, dass nur Sechsecke, die ein anderes Landschaftsfeld als die Wüste repräsentieren, eine Zahl erhalten. Außerdem werden die Zahlen entsprechend einer bestimmten Reihenfolge vergeben. Diese Reihenfolge ist durch die Listen \textit{numbers} und \textit{ints} vorgegeben. \textit{numbers} enthält die passenden Materialien und \textit{ints} eine Repräsentation dieser Materialien als Ganzzahlen, um anderen Skripten später einen einfachen Zugriff zu ermöglichen. \\
Wenn eine Zahl einem Sechseck zugewiesen wurde, dann wird diese aus dem beiden Listen entfernt. Sollte es sich bei dem betrachteten Sechseck um die Wüste gehandelt haben, so wird das Plättchen auf diesem Feld gelöscht, damit es nicht ohne Zahl auf dem Feld zurückbleibt und die Sichtbarkeit der Wüste verringert wird.

%\lstinputlisting[label=lst:Tile,caption={Hilfsklasse Tile}]{Listings/Tile.cs}
Diese Zuweisung der Zahlen als Integerwerte, kann nur deshalb erfolgen, weil es eine Hilfsklasse \textit{Tile} gibt, die Teil des Prefabs der Sechsecke ist und über ein Attribut verfügt, welches die Nummer speichert. Jedoch verfügt \textit{Tile} neben der Speicherung eines Integerwertes über keinerlei Funktionalität und ist daher nur als Hilfsklasse zu bezeichnen, weshalb sie nur im Anhang abgebildet ist.. 

Insgesamt garantiert die gewählte Umsetzung eine Variabilität im Aufbau des Spielfelds: Bei jedem Spielstart werden die Felder in eine andere Reihenfolge gebracht, sodass die gleiche Positionierung der Siedlungen in allen Spielen für die Spieler zu teilweise unterschiedlichen Ergebnissen führt. Dennoch bietet die Abspeicherung der Zahlen auf den Feldern und die Sicherung des Zugriffs auf die Oberfläche jedes Sechsecks die Möglichkeit, dass weitere Skripte die Informationen verwenden, ohne einen Umweg zu gehen.

\subsection{Der Spieler}
\label{sub:Player}
Um das Spiel spielen zu können, muss es eine Repräsentation des computergesteuerten oder menschlichen Spielers geben, der dessen Anweisungen ausführt. Hierzu wurde ein Skript \textit{PlayerScript} erstellt. Im Spiel selbst besitzt ein leeres \textit{GameObject} dieses Skript und wird damit zu einem Spieler. Hierdurch können theoretisch beliebig viele Spieler eingefügt werden.\\

\lstinputlisting[label=lst:PlayerScript1,caption={Attribute des Spielers}]{Listings/PlayerScript1.cs}

In Listing \ref{lst:PlayerScript1} ist der Beginn des \textit{PlayerScripts} zu sehen. Es verfügt über eine Vielzahl an Attributen, die unterschiedlichen Funktionen dienen. So braucht es einen eigenen Vector3, der die Perspektive, aus der der Spieler auf das Spielbrett schaut, beschreibt und auf die die ebenfalls als Attribut gespeicherte \textit{Camera} angewendet werden kann. Des Weiteren verfügt der Spieler über die Vorlage (den Prefab) zum Bau von Siedlungen (GameObject village) und Straßen (GameObject road), sowie über eine Farbe, in der später seine Objekte auf dem Spielfeld erscheinen. 

Zudem müssen seine verfügbaren Ressourcen gespeichert und eine Möglichkeit der Ausgabe durch Textfelder gegeben werden. Zusätzlich stellen die Variablen \textit{isFirstTurn} und \textit{isSecondTurn} eine Möglichkeit dar, zu prüfen, ob der Spieler sich in einem der ersten beiden Züge befindet - eine Zeit, in der Spieler kostenlos bauen darf. Dieses kostenlose Bauen kann dann durch \textit{bool freeBuild} bzw. \textit{bool freeBuildRoad} ermittelt werden. Schließlich braucht es neben zwei Listen, die alle Siedlungen (List<GameObject> villages) und alle Straßen (List<GameObject> roads) sowie die Anzahl an Siegpunkten und die Länge der längsten Straße des Spielers speichern. \\

\lstinputlisting[label=lst:PlayerScript1StartAwake,caption={Initialisierung des Spielers}]{Listings/PlayerScript1StartAwake.cs}

Die in Listing \ref{lst:PlayerScript1StartAwake} abgebildete Methode \textit{private void Awake()} initialisiert einige der Attribute auf ihre Anfangswerte, die Methode \textit{void Start()} (ebenfalls in Listing \ref{lst:PlayerScript1StartAwake} abgebildet) erreicht im Grunde das Gleiche, wird aber nach der Awake-Methode aufgerufen. Dies ist an dieser Stelle notwendig, um sichergehen zu können, dass die Text-Objekte bereits erzeugt wurden, wenn auf diese zugegriffen wird. Außerdem werden die Liste der Siedlungen und die der Straßen jeweils als leere Listen initialisiert.

\lstinputlisting[label=lst:PlayerScript2,caption={Attribute und Initialisierung des Spielers}]{Listings/PlayerScript2.cs}

In Listing \ref{lst:PlayerScript2} sind die Methoden gezeigt, die zu Beginn eines Zuges aufgerufen werden müssen. FirstTurn() wird nur im ersten Zug aufgerufen, \textit{SecondTurn()} nur im zweiten und Turn() zu Beginn jedes anderen Zuges. Alle drei Methoden beginnen damit, dass sie die Methode \textit{AdjustCamera()} aufrufen. Hierbei handelt es sich um eine Methode, die die Position der gespeicherten Kamera auf die Perspektive des Spielers setzt. Anschließend werden die bool-Werte zur Identifikation des Zuges entsprechend gesetzt sowie festgelegt, ob in diesem Zug kostenlos gebaut werden darf. In den Methoden für die ersten beiden Züge wird daher \textit{freeBuild} auf \textit{true} gesetzt, \textit{freeBuildRoad} jedoch auf \textit{false}. \textit{freeBuildRoad} wird erst \textit{true}, sobald die kostenlose Siedlung des aktuellen Zuges gebaut wurde. In \textit{Turn()} darf nicht kostenlos gebaut werden, weshalb \textit{freeBuild} und \textit{freeBuildRoad} auf \textit{false} gesetzt werden und bis zum Ende des Spiels auf diesem Wert bleiben.

\lstinputlisting[label=lst:PlayerScript3,caption={Attribute und Initialiserung des Spielers}]{Listings/PlayerScript3.cs}

Nachdem Listing \ref{lst:PlayerScript2} und Listing \ref{lst:PlayerScript1} die Initialisierung des Spielers und seiner Züge zeigten, bringt Listing \ref{lst:PlayerScript3} die erste Funktionalität mit sich: Abgebildet sind zwei Methoden. Erstere (\textit{HasRessoucesForVillage()}) überprüft , ob der Spieler genug Ressourcen zum Bau einer Siedlung hat, die zweite Methode (\textit{HasRessourcesForRoad()}) bewerkstelligt dies analog für die Straßen. Für eine Siedlung benötigt der Spieler jeweils eine Einheit Lehm, Holz, Schafe und Getreide. Für eine Straße nur jeweils eine Einheit Holz und Lehm. Über die Ressourcenvariablen wird abgefragt, ob diese Rohstoffe vorhanden sind. Dementsprechend wird ein bool-Wert zurückgegeben.

\lstinputlisting[label=lst:PlayerScript4,caption={Attribute und Initialiserung des Spielers}]{Listings/PlayerScript4.cs}

Neben dem Bau von neuen Siedlungen, muss auch der Nutzen einer solchen ermittelt werden. Jede Siedlung kann dem Besitzer bestimmte Rohstoffe einbringen. Hierzu existieren zwei Methoden \textit{CollectResourcesForVillage(GameObject village)} und \textit{CollectResources(int number)}. Beide erreichen im Grunde das Gleiche, wobei \textit{CollectResourcesForVillage(GameObject village)} die Rohstoffe für eine konkrete Siedlung sammelt und \textit{CollectResources(int number)} abhängig von der gewürfelten Nummer die Rohstoffe verteilt. Exemplarisch ist in Listing \ref{lst:PlayerScript4} nur \textit{CollectResources(int number)} aufgeführt. Die andere ist äquivalent und daher nur im Anhang zu finden. \\
Zu jeder Siedlung werden die angrenzenden Felder gespeichert. Diese können entweder \textit{null} oder von einem bestimmten Typus sein, der über dessen \textit{Material} abgefragt wird. Auf diese Weise kann durch verschachtelte if-Verzweigungen ermittelt werden, ob und welche Rohstoffe dem Spieler zuzusprechen sind. Am Ende beider Methoden wird \textit{UpdateResources()} aufgerufen, eine Methode, die die aktualisierten Mengen an Rohstoffen ausgibt. 

\lstinputlisting[label=lst:PlayerScript5,caption={Attribute und Initialisierung des Spielers}]{Listings/PlayerScript5.cs}

Nachdem oben erläutert wurde, wie die Ermittlung der nötigen Menge an Rohstoffen zum Bau einer Siedlung oder Straße erfolgt und der Ertrag einer Siedlung berechnet wird, stellt Listing \ref{lst:PlayerScript5} den tatsächlichen Bau von Siedlungen und Straßen dar. Die Methode \textit{BuildVillage(Vector3 position)} bekommt als Parameter die Position für den Bau der Siedlung übergeben und kann diese dort platzieren. Zu Beginn der Methode wird überprüft, ob der Spieler kostenlos bauen darf bzw. ob er genug Rohstoffe zum Bauen hat. Falls er genug Rohstoffe hat, aber nicht kostenlos bauen darf, bezahlt der Spieler entsprechend mit den Rohstoffen. Wenn allerdings kostenlos gebaut werden darf, wird die Möglichkeit des kostenlosen Bauens genutzt. Anschließend würde dann der kostenlose Bau einer Straße erlaubt werden.

In jedem Fall wird im Anschluss an diese Prüfung eine neue Siedlung auf Grundlage des \textit{GameObjects village} instanziiert. Bei dem instanziierten Objekt handelt es sich um eine weitere Instanz, des bereits als Repräsentation instanziierten und dafür vorgesehenen \textit{Prefabs}. Dieser Instanz wird die zuvor übergebene Position zugeschrieben und sie erhält die Farbe des Spielers als Oberflächenfarbe. Nachfolgend werden die Siegpunkte des Spielers um eins erhöht sowie seine Menge an Rohstoffen aktualisiert und schließlich wird die Instanz der Siedlung zurückgegeben.

Die Methode zum Bau einer Straße funktioniert äquivalent zum Bau von Siedlungen, wobei insofern ein Unterschied besteht, als dass der Spieler sämtliche kostenlosen Baurechte verliert und eine Rotation an der Straße vorgenommen werden muss. Die Methode erhält den Grad der Rotation als Parameter und kann diese nun auf die neue Instanz anwenden. Das ist im Gegensatz zur Methode für Siedlungen nötig, weil Straßen auf den Kanten zweier Sechsecke stehen und diese in eine bestimmte Richtung zeigen. Damit dies auf dem Spielfeld ansehnlicher aussieht, werden die instanziierten Straßen in dieselbe Richtung gedreht.

In den Spielregeln (s.Anhang) ist angegeben, dass die kostenlosen Straßen im ersten bzw. zweiten Zug eines Spielers nur an die Siedlung gebaut werden dürfen, die im jeweiligen Zug errichtet wurden. Im Zuge der Implementation wird auf diese Regel verzichtet. Der Bau der zweiten Straße kann dadurch auch an die bestehende Straße erfolgen. Dies kann als weiteres strategischen Element aufgefasst werden.

\lstinputlisting[label=lst:PlayerScript6,caption={Attribute und Initialiserung des Spielers}]{Listings/PlayerScript6.cs}

Listing \ref{lst:PlayerScript6} führt die Berechnung der längsten Straße eines Spielers ein. Hierfür sind zwei Methoden nötig. Die erste Methode \textit{CalculateRoadLength} prüft zunächst, ob der Spieler überhaupt Straßen besitzt. Falls dies wahr ist, wird eine neue Liste zur späteren Speicherung der Längen aller Straßen angelegt. Nun werden alle Straßen in der globalen Liste \textit{roads} mittels foreach-Schleife durchlaufen. Für jede Straße wird zu Beginn die globale Liste ohne Inhalt initialisiert und anschließend wird die Menge an Nachbarn für diese Straße ermittelt. Die Anzahl der Nachbarn stellt die Länge der Straße dar und durch das Ausfindigmachen des Maximums der Liste \textit{roadLengths} kann die längste Straße des Spielers ermittelt werden. Sollte der Spieler über keine Straßen verfügen, hat die längste Straße eine Länge von 0. 

Zum Berechnen der Anzahl der Nachbarn einer Straße wird die zweite Methode \textit{FindRoadNeighbors(GameObject road)} genutzt. Diese ermittelt, wie viele Straßen von der betrachteten Straße abgehen. Am Anfang der Methode gibt es 0 Nachbarn und eine leere Liste. Anschließend wird für jedes Objekt in der globalen Liste \textit{roadsModified} die Distanz zur - als Parameter übergebenen - Straße berechnet. Sollte die Distanz geringer sein als die Distanz, die einen direkten Nachbarn kennzeichnet, so handelt es sich bei der betrachteten Straße um einen direkten Nachbarn. Damit für eine alleinstehende Straße eine Länge von eins errechnet wird, wird sie als Nachbar von sich selbst angesehen. Wird ein Nachbar gefunden , wird dieser aus \textit{roadsModified} entfernt und zu \textit{roadsupdated} hinzugefügt. Außerdem wird die Anzahl der Nachbarn um eins erhöht. Wenn die betrachtete Straße allerdings kein direkter Nachbar der übergebenen Straße ist, so wird \textit{i} um eins erhöht, um zur nächsten Straße überzugehen.

Anschließend wird für jede Straße in \textit{roadsUpdated} erneut \textit{FindRoadNeighbors(GameObject road)} aufgerufen. Das Ergebnis dieses Aufrufs wird wiederum zu der Anzahl der aktuellen Nachbarn hinzugezählt. Durch dieses rekursive Vorgehen kann die komplette Länge aller zusammenhängenden Straßen berechnet werden. Ist die Rekursion abgeschlossen, wird die Anzahl der Nachbarn zurückgegeben.

Da \textit{CalculateRoadLength()} die Anzahl der Nachbarn für jede Straße kalkuliert, ist insofern sichergestellt, dass tatsächlich die längste Straße gefunden wird, als dass jede Straße einmal als Startpunkt fungiert.

\subsection{Der Gamemanager}
\label{sub:GameManager}
Der Gamemanager dient der Steuerung des Ablaufs des Spiels. Hierüber wird später der Zugriff auf die Schnittstelle gewährleistet, sodass KI-Spieler und Spiel miteinander interagieren können. Dieser Manager sorgt für einen reibungslosen Ablauf des Spiels, weißt zu, welcher Spieler am Zug ist und überprüft alle Geschehnisse, die während des Spiels vor sich gehen. Ohne ihn wäre kein Zusammenspiel der Spieler bzw. überhaupt kein Spiel möglich.

\lstinputlisting[label=lst:GameManager1,caption={Initialisierung und Spielerwechsel}]{Listings/GameManager1.cs}

In Listing \ref{lst:GameManager1} werden zwei Methoden gezeigt. Vor der Methode \textit{ChangePlayer} wären normalerweise die Awake- und die Startmethode sowie die Liste der deklarierten Attribute zu finden. Aus Platzgründen wurde hier auf die Einbindung dieser Abschnitte verzichtet, diese können jedoch im Anhang eingesehen werden. Erklärungen zu betroffenen Variablen sind weiterhin in der Beschreibung ihrer Verwendung zu finden. Zusätzlich fehlen einige Teile der \textit{UpdateActivePlayer(PlayerScript player)}-Methode, da diese sonst zu lang gewesen wäre. Entfernte Stellen sind jeweils durch drei Punkte gekennzeichnet.

Neben \textit{UpdateActivePlayer} existiert auch \textit{ChangePlayer()}. Diese rotiert zunächst die Kamera um 180 Grad in der Vertikalen, um den Spielerwechsel für einen menschlichen Betrachter zu signalisieren. Anschließend wird der nächste Spieler aktiv, wodurch er seinen Zug beginnt.

Auch in der \textit{ChangePlayer-Methode} wird zum Setzen des aktuellen Spielers die \textit{UpdateActivePlayer}-Methode genutzt. Diese Methode bekommt als Parameter das Skript des zu setzenden Spielers und aktualisiert damit die globale Variable \textit{activePlayer}. Anschließend werden die Siegpunkte des Spielers aktualisiert - zunächst durch den Aufruf der passenden Methode des aktuellen Spielers, dann durch einen Vergleich der jeweils längsten Straße beider Spieler. Der Spieler mit der längsten Straße erhält zwei zusätzliche Siegpunkte. Die Siegpunkte zuvor zu aktualisieren sowie die Vernachlässigung der längsten Straße sind innerhalb dieser Methode nötig, weil ansonsten der Spieler, der zuvor die längsten Straße besessen hat, seine Punkte nicht wieder verlieren würde.

Im nächsten Schritt muss ein potenzieller Siedlungsbauplatz erfahren, welchem Spieler die Errichtung einer Siedlung zugeordnet werden würde. Hierzu müssen zunächst die deaktivierten Bauplätze aktiviert werden, anschließend wird dann dem verantwortlichen Skript jedes Bauplatzes der aktuelle Spieler als Attribut mitgeteilt. Um dies zu erreichen, wird zunächst mithilfe einer Schleife jeder potenzielle Bauplatz durchlaufen und aktiviert. Anschließend wird das Elternelement ebenfalls aktiviert. Nun kann über das Skript jedes Bauplatzes iteriert und der aktuelle Spieler gesetzt werden. Anschließend erfolgt die Deaktivierung aller Bauplätze sowie  des Elternelementes. Dies ist nötig, da ohne den Aktivierungsschritt kein Zugriff auf die Skripte erfolgen könnte. Dieser Prozess bist für den Nutzer allerdings unsichtbar. \\
Das gleiche Vorgehen wird auch auf die potenziellen Bauplätze von Straßen angewandt: Auch diese benötigen den aktuellen Spieler, um feststellen zu können, wer die angefragte Straße bauen möchte. \\

\lstinputlisting[label=lst:GameManager2,caption={Update-Methode}]{Listings/GameManager2.cs}

Listing \ref{lst:GameManager2} zeigt die Methode \textit{Update()}. Sie wird kontinuierlich aufgerufen und daher dauerhaft ausgeführt. Sie beinhaltet Anweisungen, die immer wieder durchgeführt werden müssen. Der Aufruf geschieht durch \textit{Unity} und wird nicht selbstständig gesteuert. \\
Zu Beginn der Methode wird überprüft, ob potenzielle Bauplätze für Siedlungen aktiviert werden sollen. Hierzu muss der Spieler, der am Zug ist, auf dem Spielfeld die Repräsentation der Siedlung ausgewählt haben. In solch einem Fall wird  \textit{villageFocus.hasFocus} wäre auf \textit{true} gesetzt und die Überprüfung der weiteren Bedingungen findet statt. Sofern es sich um den ersten oder zweiten Zug des Spielers handelt, werden alle potenziellen Bauplätze angezeigt und es kann auf einem dieser Plätze gebaut werden. Jedoch schränkt der Bau einer Siedlung die Plätze für potenziell folgende Siedlungen ein, da sich zwischen zwei Siedlungen mindestens Platz für zwei Straßen befinden muss. Um dies zu gewährleisten, werden die Bauplätze in einem zuvor festgelegtem Umkreis durch die Methode \textit{DestroyVillagePlacesInRadius()} gelöscht. \\
Sollte es sich bei dem aktuellen Zug um einen Standardzug handeln, so wird in der Bedingung einer \textit{else if-Abzweigung} geprüft, ob der Spieler genügend Ressourcen hat. Falls dem so ist, darf er eine Siedlung bauen - allerdings nur dort, wo ein Siedlungsbauplatz an einer bestehenden Straße liegt. Dadurch und durch die Löschung der zu nah an anderen Siedlungen gelegenen Bauplätze wird die Einhaltung der Zwei-Straßen-Abstand-Regel umgesetzt. Konkret funktioniert die Prüfung, ob eine Straße anliegt, indem alle gebauten Straßen des Spielers durchlaufen werden und somit überprüft wird, ob ein Bauplatz an diesen anliegt. Der anliegende Bauplatz wird daraufhin aktiviert und für den Spieler sichtbar. \\
Falls sich keine der beiden obigen Bedingungen als wahr herausstellt, so werden die angezeigten Bauplätze wieder deaktiviert. Durch den kontinuierlichen Aufruf der Update-Methode gibt es keine merkbare Verzögerung für den Spieler und die Deaktivierung der Bauplätze erfolgt, sobald ein erneuter Klick auf die Repräsentation vorgenommen wird, der Spieler nicht mehr kostenlos bauen darf oder seine Ressourcen nicht mehr ausreichen, um eine weiter Siedlung zu errichten. \\

\lstinputlisting[label=lst:GameManager2ActivateRoads,caption={Update-Methode Aktvierung der Bauplätze für Straßen}]{Listings/GameManager2ActivateRoads.cs}

Das gleiche Prinzip wird mit wichtigen Anpassungen auch auf den Bau von Straßen angewandt (siehe Listing \ref{lst:GameManager2ActivateRoads}). Bei den Siedlungen gilt, dass im ersten und zweiten Zug jeder ungelöschte Bauplatz für den Bau einer Siedlung infrage kommt. Bei den Straßen ist dies anders: Hier darf der Bau einer Straße nur dann erfolgen, wenn direkt an am Bauplatz entweder bereits eine Siedlung oder eine weitere Straße gebaut wurde. Die Überprüfung erfolgt erneut durch die Iteration über alle Siedlungen in der äußeren Schleife sowie über alle Bauplätze für Straßen in der inneren Schleife. Es werden nur die Bauplätze aktiviert, die sich direkt an einer bereits existierenden Siedlung befinden. Anschließend wird das gleiche Prozedere für die bereits existierenden Straßen vorgenommen und auch hier werden die anliegenden Bauplätze freigeschaltet. Anders als bei der Aktivierung der Siedlungsbauplätze, kann die für die Straßen ohne weitere Verzweigung in else if-Form ablaufen, da der Ablauf der Aktivierung in beiden Fällen der gleiche ist. Die Deaktivierung der Bauplätze wiederum erfolgt äquivalent. \\

\lstinputlisting[label=lst:GameManager3,caption={Würfeln}]{Listings/GameManager3.cs}

Ein weiterer wichtiger Bestandteil des \textit{Gamemanagers} ist das Würfeln. Listing \ref{lst:GameManager3} zeigt die Implementierung dieser Funktionalität. s werden hierfür zwei Methoden benötigt: Die erste Methode, \textit{OnRollDice()}, löscht zunächst den vorherigen Würfelversuch, um dann anschließend zwei rote sechsseitige Würfel zu werfen. Daraufhin wird das erneute Würfeln verboten und es werden zwei Coroutinen gestartet. Die eine dieser \textit{Coroutinen} dient dem Hinzufügen von Ressourcen zum Bestand der Spieler, die andere dem Erlauben des Bauens und Beendens des Zuges. \\
Die Würfel stammen aus der Asset-Bibliothek von Unity und wurden nicht selbst imple- mentiert. Es wird hier lediglich auf eine bereits vorhandene Implementation zugegriffen, daher entfällt eine genauere Betrachtung des Vorgangs des Würfels. \\

Die besagten Routinen sind ebenfalls abgebildet. Die erste der beiden \textit{IEnumerator} - AddResources() - dient dem Hinzufügen der Rohstoffe zu den Beständen aller Spieler. Welcher Spieler Rohstoffe erhält, ist von der gewürfelten Zahl sowie davon abhängig, ob ein Spieler eine Siedlung an dem mit der Zahl korrespondierenden Landschaftsfeld hat. Dementsprechend wird zu Beginn der Routine für drei Sekunden gewartet, damit das Würfeln auf jeden Fall abgeschlossen ist. In einigen Fällen kann es jedoch dazu kommen, dass der Würfel auf seiner Kante hängen bleibt. Dann können keine Rohstoffe verteilt werden und der Zug läuft so weiter ab als hätte der Spieler nicht gewürfelt. Um ein solches Fehlverhalten auszugleichen, könnte auf die festgeschriebene Wartezeit verzichtet werden und die Verteilung stattdessen erst dann vorgenommen werden, wenn das Würfeln abgeschlossen ist. Würde das Würfeln nicht in einer bestimmten Zeit abgeschlossen, weil die Würfel beispielsweise festhängen, so könnte der Würfelversuch wiederholt werden. Dieses Verhalten ist wünschenswert, zum aktuellen Stand der Entwicklung aber verzichtbar. \\
Nachdem die beiden Spieler ihre Rohstoffe erhalten haben, wird die Rohstoffanzeige des aktuellen Spielers aktualisiert, um den Bestand und die Darstellung konsistent zu halten.

In der ebenfalls gezeigten Routine - EnableEndTurn() - wird zu Beginn vier Sekunden gewartet. Die längere Wartezeit ist darauf zurückzuführen, dass die Darstellung des aktualisierten Rohstoffbestands abgeschlossen sein soll. Nachdem gewartet wurde, wird der Button aktiviert, mit dem der Spieler seinen Zug beenden kann. Es soll jedoch zuvor wenigstens kurz angezeigt werden, welche Rohstoffe er aktuell besitzt. Dadurch kann er den neuen Bestand in seine Entscheidung miteinbeziehen und prüfen, ob er seinen Zug überhaupt schon beenden oder ob er zuvor weitere Aktionen vornehmen will. Für einen menschlichen Spieler stellt eine gleichzeitige Aktualisierung der Rohstoffe und Aktivierung des Buttons zur Zugbeedung  kein Problem dar. Bei einem computergesteuerten Gegner könnte dies jedoch zu Fehlern führen. Es müsste intern implementiert werden, dass der Computer abwartet, um festzustellen, welche Rohstoffe er erhält und dann überlegen zu können, ob der Zug tatsächlich beendet werden soll. Durch die Verzögerung kann auf eine solche Implementation allerdings verzichtet werden.

Die Verwendung von Routinen bietet sich für die beiden oben genannten Anwendungsfälle an, da sie für eine parallele Abarbeitung der Geschehnisse sorgen. Dies wirft allerdings die Frage auf, ob nicht auch der Hauptthread pausiert werden könnte. Es gilt jedoch: Das Warten ist nur deshalb sinnvoll, weil im Hintergrund weitere Prozesse ablaufen. Würde der Hauptthread warten, so würde das gesamte Spiel angehalten werden, wodurch das Auswerten der Würfel keinen Effekt mehr hätte, da diese noch gar nicht geworfen worden wären. Gleiches gilt für die Aktivierung des Buttons. Dieser soll erst dann aktiv werden, wenn die Augenzahl bereits errechnet und verarbeitet wurde. Hielte man dafür den Hauptthread an, könnte keine Verarbeitung stattfinden. Durch das Verteilen der Prozesse auf unterschiedliche Threads können die Timer parallel ablaufen und so den gewünschten Effekt erreichen.

\lstinputlisting[label=lst:GameManager4,caption={Zug beenden}]{Listings/GameManager4.cs}

Wird der Button zum Beenden des Zuges betätigt, ruft dies die Methode \textit{OnEndTurn()} auf. Abgebildet ist sie als Listing \ref{lst:GameManager4}. Am Anfang der Methode ist eine if-Verzweigung zu sehen. Diese dient der Bestimmung des Siegers. Sollte ein Spieler in seinem aktuellen Zug die nötigen Siegpunkte erreicht bzw. überschritten haben, so  ist dieser der Sieger des Spiels. In diesem Fall wird das Spiel beendet und der aktuelle Spieler als Sieger ausgegeben. Erreicht der aktuelle Spieler die nötige Anzahl der Siegpunkt nicht bzw. hat er nicht gewonnen, so wird der Rest der Methode ausgeführt: Im ersten Schritt wird dann geprüft, ob der aktuelle Spieler gerade seinen ersten Zug gemacht hat und ob es sich bei ihm um \textit{Spieler 1} handelt. Sollte dies der Fall sein, wird auf \textit{Spieler 2} gewechselt, sodass die Kamera sich dreht und \textit{Spieler 2} seinen ersten Zug machen darf. Zudem müssen die Buttons zum Würfeln und zum Beenden des Zuges wieder deaktiviert werden. Falls es sich bei dem aktuellen Zug jedoch bereits um den ersten Zug von \textit{Spieler 2} handelt, so wird die Kamera nicht gedreht, da er am Zug bleibt. Er darf direkt seinen zweiten Zug ausführen. Wenn er seinen Zug beendet, erhält \textit{Spieler 2} die Rohstoffe für seine in Zug 2 kostenlos gebaute Siedlung. Anschließend wird zum zweiten Zug von \textit{Spieler 1} gewechselt. Dieser Zug ist der letzte vor den gewöhnlichen Spielzügen. Wird dieser beendet, so erhält auch \textit{Spieler 1} Rohstoffe für die zuletzt gebaute Siedlung. Er darf  anschließend mit dem ersten Standardzug beginnen. Zunächst wird allerdings der Würfelbutton aktiviert, damit der Spieler diesen zu Beginn seines Zuges betätigen kann. Die Standardzüge werden in \textit{OnEndTurn()} durch den \textit{else}-Zweig der bisher beschriebenen Fallabfrage bearbeitet. Sollte keine der zuvor beschriebenen Bedingungen wahr sein, so muss es sich um einen Standardzug handeln. Dieser wird durch den Aufruf der bereits beschriebenen Methode \textit{ChangePlayer()} (siehe Listing \ref{lst:GameManager1}) nd die darauffolgende Aktivierung des Würfelbuttons sowie die Deaktivierung des Buttons zur Zugbeendung beendet. \\
Unabhängig davon, welche der obigen Anweisungen aufgrund der geltenden Bedingungen durchgeführt wurden, in jedem Fall wird am Schluss der Methode der Bestand der Rohstoffe des aktiven Spielers aktualisiert. \\

\subsection{Die Repräsentation der Bauobjekte}
In der Beschreibung des Spielfelds wurde erwähnt, dass die abgebildeten Objekte, die zu bauenden Siedlungen (siehe Abb. \ref{fig:Spielfeld-Blueprint}, links oben) und  Straßen (\ref{fig:Spielfeld-Blueprint}, rechts unten) darstellen. In Kapitel \ref{sub:GameManager} wurde auf die Nutzung dieser Objekte eingegangen und festgehalten, dass sie dem Zweck dienen, den Baumodus für die jeweiligen Objekte an- und ausschalten zu können. \\

\lstinputlisting[label=lst:VillageFocus,caption={Aktivierung des Baumodus für Siedlungen}]{Listings/VillageFocus.cs}

Listing \ref{lst:VillageFocus} zeigt, wie dieser Mechanismus für den Baumodus von Siedlungen implementiert ist. Sobald die angesprochene Repräsentation auf dem Spielfeld angeklickt wird, wird der Baumodus aktiviert, sofern er deaktiviert ist bzw. deaktiviert, wenn er aktiviert ist. Beachtet werden sollte in diesem Zusammenhang zudem die Variable \textit{roadFocus}. Diese enthält das äquivalente Skript für die Straßen und gewährleistet, dass nicht beide Modi gleichzeitig zur Verfügung stehen. Das bedeutet, falls der Baumodus für Siedlungen aktiviert wurde, wird der für Straßen entsprechend deaktiviert. Eine äquivalente Klasse zur Aktivierung des Baumodus für Straßen befindet sich im Anhang.

\subsection{Der Bau von Siedlungen und Straßen}

Die Klasse \textit{buildVillage} (siehe Listing \ref{lst:BuildVillage}) ist das Skript eines jeden Bauplatzes für Siedlungen. Sie verfügt über zwei globale Variablen, die den aktuellen Spieler und den verantwortlichen GameManager repräsentieren. Als einzige Methode verfügt sie über die Methode \textit{OnMouseDown()}, die als OnClick-Reaktion pro Bauplatz fungiert. Dieser OnClick-Mechanismus funktioniert nur, wenn die Bauplätze aktiviert sind, daher wurde im Abschnitt \ref{sub:GameManager} ausgiebig beschrieben, wann dies der Fall ist. \\
Wenn ein aktivierter Bauplatz angeklickt wird, wird zunächst, mit der dafür vorgesehenen Methode \textit{BuildVillage(Vector3 position)}, die in der Klasse PlayerScript \ref{lst:PlayerScript5} zu finden ist und durch den aktiven Spieler aufgerufen wird, eine Instanz einer Siedlung erzeugt. Die Erzeugung einer neuen Instanz für den aktuellen Spieler ist in Kapitel \ref{sub:Player} näher beschrieben. Nachdem die Instanz zurückgeliefert wurde, wird auf sein Skript \textit{Village} zugegriffen. Dieses ist unter Listing \ref{lst:VillagePlaceScript} zu sehen. Bei diesem Skript handelt es sich jedoch nur um eine Hilfsklasse, die lediglich ein einziges Attribut in Form einer Liste (genannt \textit{Tiles}) beinhaltet. Ähnlich funktioniert das Skript \textit{PlaceScript}. Dieses enthält drei Attribute, die der Speicherung der anliegenden Landschaftskarten dienen. Mithilfe dieser beider Klassen können dem entstandenen Dorf angrenzenden Ressourcen vermittelt werden. Diese Zuweisung ist in den Zeilen 13-18 zu sehen. Die Prüfung auf \textit{null}-Werte erfolgt zusätzlich, da noch keine Wasserfelder existieren und einige Bauplätze, die nicht an drei Felder grenzen, zum Teil \textit{null}-Werte enthalten können. \\
Abschließend wird das entstandene Dorf der Liste der Dörfer des Spielers (s. Zeile 20) hinzugefügt, damit später darauf zugegriffen werden kann. Zudem erhält der \textit{Gamemanager} Zugriff auf die entstandene Instanz. Diese Setzung der Variable löst die in Abschnitt \ref{sub:GameManager} beschriebene Löschung der benachbarten Bauplätze durch die Update-Methode aus. \\

\lstinputlisting[label=lst:BuildVillage,caption={Bau von Siedlungen}]{Listings/BuildVillage.cs}

In Listing \ref{lst:BuildRoad} ist der gleiche Ablauf für den Bau von Straßen zu sehen. Hier sind wieder der aktive Spieler und der verantwortliche Gamemanager gespeichert. Auch für die Straßen wird die Instanziierung über die entsprechende Methode des Spielers vorgenommen. Sofern die dabei entstandene Instanz ungleich \textit{null} wird sie der Liste der Straßen des Spielers hinzugefügt, woraufhin seine längste Straße erneut ermittelt wird und der Gamemanager Zugriff auf die Instanz erhält. Abschließend wird noch das aufrufende GameObject zerstört, um den Bauplatz unter der Straße zu entfernen. Dieser Schritt entfällt hingegen beim Bau von Siedlungen, da hier stattdessen im Nachhinein alle Bauplätze im Nachbarradius zerstört werden. \\

\lstinputlisting[label=lst:BuildRoad,caption={Bau von Straßen}]{Listings/BuildRoad.cs}

\lstinputlisting[label=lst:VillagePlaceScript,caption={Hilfsklassen Village und PlaceScript}]{Listings/VillagePlaceScript.cs}

\section{Die Schnittstelle}
\label{sec:Schnittstelle}
Die Schnittstelle wurde bereits im Kapitel \ref{cha:Entwurf} thematisiert, jedoch soll nachfolgend genauer auf die konkrete Implementation dieser  eingegangen werden. Zunächst wurde die Entscheidung getroffen, dass die KIs auf Java basieren sollen, da so während  der Implementation eine einfache Nutzung eines \textit{Case Based Reasoning-System}s (CBR-Systems) möglich ist. Grundlegend wurde sich bei der Implementation an der Masterarbeit von Jannis Hillmann \cite[vgl.]{Hillmann2017} orientiert. In seiner Arbeit wendet er ein ähnliches Konzept auf einen \textit{Ego-Shooter} an. Im Rahmen dieses Projekts wurde  vor allem auf Hillmanns Java-Klasse \textit{CBRSystem.jar} zurückgegriffen, die entsprechend angepasst wurde.

Die Klasse \textit{CBRSystem.jar} aktiviert einen Server, der vom Client (dem Spiel) angesteuert werden kann, um Anfragen zu stellen, die in Form von Anweisungen von der KI beantwortet werden. Die Kommunikation zwischen dem Server und dem Client findet hierbei ? wie geplant -  mittels \textit{JSON} statt. Die Anfragen, die das Spiel an den Server richtet, bestehen immer aus einer ganzen Situation. Das bedeutet, die KIs werden über die Schnittstelle jedes Mal über den aktuellen Spieler sowie über den Zustand des Spiels und des Spielers informiert.
\\
\lstinputlisting[label=lst:Situation-Attribute-Ausschnitt,caption={Die relevanten Informationen für eine Situation}]{Listings/Situation-Attribute-Ausschnitt.cs}

Listing \ref{lst:Situation-Attribute-Ausschnitt} zeigt die Attribute einer Situation. Auffällig ist, dass der Name des Spielers als \textit{String} gespeichert wird, die Karte und der Status aber jeweils durch eigene Klassen repräsentiert werden. Die Klasse \textit{Status} bedarf an dieser Stelle keiner weiteren Erläuterung, da dort lediglich die Attribute des betroffenen Spielers zur Verarbeitung durch \textit{JSON} gespeichert werden. Bei der Klasse \textit{Map} ist dies ähnlich, allerdings muss hier ein Weg gefunden werden, die sichtbare Karte als abstraktes Objekt zu formulieren. Zu sehen sind die Attribute in Listing \ref{lst:Karte-Attribute-Ausschnitt}. Einerseits wird hier ein \textit{Enum} genutzt, um die Ressourcen der einzelnen Felder verwalten zu können, andererseits werden drei Listen gespeichert, die die Felder, die Siedlungsbauplätze und die Straßenbauplätze enthalten sind. Hierbei ist zu beachten, dass es sich bei den gespeicherten Objekten nicht um die \textit{GameObjects} auf dem Spielfeld handelt. Stattdessen wurden jeweils eigene Klassen definiert, die die nötigen Informationen über jedes Objekt enthalten.
\\
\lstinputlisting[label=lst:Karte-Attribute-Ausschnitt,caption={Die Attribute der Klasse Map}]{Listings/Karte-Attribute-Ausschnitt.cs}

Die beiden Klassen zur Speicherung von Bauplätzen verfügen jeweils über ein Attribut, das der Prüfung der Aktivierung des Bauplatzes sowie einer potentiellen Veränderung dieses Zustands durch entsprechende Methoden dient. Die Klasse \textit{Tile} speichert Informationen über die Sechsecke des Spielfeldes und benötigt hierfür Informationen über die Nummern der Sechsecke und die Art des Feldes. Um dies zu ermöglichen, wird das Enum genutzt.

Durch die angeführten Klassen und Methoden wird zwar das Speichern des sichtbaren Spielfeldes möglich, jedoch muss auch eine Verbindung zwischen den abstrakten Modellen und dem Spiel selbst aufgebaut werden, damit die benötigten Informationen gewonnen werden können. Um dies zu gewährleisten, wird bereits bei der Generierung des Spielfeldes eine erste Verbindung aufgebaut. Listing \ref{lst:MapGeneratorAnpassungCreateMap1} zeigt die Erstellung eines abstrakten Feldes. Dies geschieht für jedes sichtbare Feld, dass kreiert wird. Es speichert Informationen über die Nummer des jeweiligen Feldes und die darin vorhandenen Ressourcen. Nach der Erstellung wird es der entsprechenden Liste in der Karte hinzugefügt.
\\
\lstinputlisting[label=lst:MapGeneratorAnpassungCreateMap1,caption={Verknüpfung der Erstellung der Karte und den Feldern}]{Listings/MapGeneratorAnpassungCreateMap1.cs}

Die Verlinkung der Bauplätze wird nach der Generierung des Spielfeldes im \textit{GameManager} aufgebaut. Listing \ref{lst:GMLateStart} zeigt die Methode \textit{LateStart()}. Diese wird einmal zu Beginn des ersten Aufrufs der \textit{Update()}-Methode aufgerufen. Hierdurch wird sichergestellt, dass die Start-Methode aller anderen Skripte bereits ausgeführt wurde und es zu keinen \textit{Exceptions} kommt. Konkret muss auf die Erstellung der Karte im \textit{MapGenerator} und auf die der physischen Bauplätze gewartet werden. Diese Methode übernimmt zunächst die Kontrolle über die Karte des \textit{MapGenerators} und lädt anschließend aus jedem Bauplatz den enthaltenen abstrakten Bauplatz, um diesen in der passenden Liste der Karte zu speichern. Der abstrakte Bauplatz wird zur Laufzeit in jedem physischen Bauplatz in der Startmethode erstellt, sodass eine Zuordnung möglich wird. Nachdem dies geschehen ist, darf der erste Zug des ersten Spielers ausgeführt werden, da nun alle Vorbereitungen abgeschlossen wurden. Dazu wird die erzeugt und der erste Zug für von \textit{Spieler 1} begonnen. 

\lstinputlisting[label=lst:GMLateStart,caption={GameManager: LateStart}]{Listings/GMLateStart.cs}

\lstinputlisting[label=lst:GMStartAIProcess,caption={GameManager: StartAIProcess}]{Listings/GMStartAIProcess.cs}

Die Methode \textit{StartAIProcess()} dient dem Starten des Servers, zu dem sie die Verbindung aufbaut (siehe Listing \ref{lst:GMStartAIProcess}). Die Methode \textit{MakeAITurn} (Listing \ref{lst:GMMakeAITurn}) wird anschließend aufgerufen, um die erste Anfrage an den Server geschickt werden kann. Die Methode startet fünf Co-Routinen, die jeweils um das angegebene \textit{Delay} eine Anfrage an den Server schicken (siehe ActivateAi(), Listing \ref{lst:GMMakeAITurn}). Als auf diese Anfrage Antwort wird ein Plan erwartet, der für den aktiven Spieler ausgeführt werden kann. Hierzu muss erwähnt werden, dass Methode und \textit{IEnumerator} nur für die ersten beiden Züge jedes Spielers verwendet werden. Anschließend werden \textit{MakeAiMainTurn} und \textit{ActivateAiMainTurn} verwendet, die im gleichen Listing \ref{lst:GMMakeAITurn} abgebildet sind. Der Unterschied besteht darin, dass der zuletzt gezeigte IEnumerator zunächst gestartet wird und anschließend rekursiv erneut eine Anfrage verschickt, falls der empfangene Plan keine Anweisung zum Beenden des Zuges enthält. 

\lstinputlisting[label=lst:GMMakeAITurn,caption={Ausführen einer Anfrage an den Server}]{Listings/GMMakeAITurn.cs}

Die Verarbeitung der Pläne erfolgt im \textit{PlayerScript} eines Spielers selbst. Hierzu muss das Skript so erweitert werden wie in Listing \ref{lst:PlayerScriptFulfillPlan} dargestellt. Die angefügte Methode erlaubt die Ausführungen von geforderten Aktionen eines Plans. Hierzu wird eine for-Schleife genutzt, die den kompletten Plan eines Spielers durchläuft und nacheinander jede enthaltene Aktion verarbeitet. Ob eine Aktion durchgeführt werden kann, hängt davon ab, ob die nötigen Bedingungen erfüllt sind und ob die jeweilige Aktion existiert. Jede Aktion wird durch eine eigene Klasse repräsentiert, die von der abstrakten Klasse Aktion erbt. Bereits verfügbar sind das Aktivieren und Deaktivieren von Bauplätzen, das Bauen von Straßen und Siedlungen (auf zufälligen Bauplätzen) ,das Beenden von Zügen sowie das Würfeln. Welche dieser Aktionen ausgeführt wird, hängt jeweils davon ab, welcher Klassenname an der entsprechenden Stelle in der Liste des Plans steht.

\lstinputlisting[label=lst:PlayerScriptFulfillPlan,caption={PlayerScript: FulfillPlan}]{Listings/PlayerScriptFulfillPlan.cs}

Der Plan wird auf Seiten des Servers zusammengestellt. Hierfür sind vor allem drei Klassen von Relevanz: \textit{CBRSystem, PlayerManager} und \textit{Player}. Die Klasse \textit{CBRSystem} ist für die Verbindung zwischen Client und Server verantwortlich. Sie empfängt Anfragen des Spiels und sendet die Antworten der KI ab. Die Verarbeitung der Anfragen wird allerdings in den anderen beiden genannten Klassen vorgenommen. In der Klasse \textit{PlayerManager} wird mithilfe von Informationen aus der Anfrage über das Ansteuern des richtigen Spielers entschieden. Außerdem sorgt diese Klasse dafür, dass die Informationen, die der KI zur Verfügung stehen, aktuell sind. Die Spieler entwickeln auf Grundlage dieser Informationen einen Plan, der in der Klasse \textit{PlayerManager} zu einer Antwort in Form eines Response-Objektes geformt, an die aufrufende Klasse \textit{CBRSystem} zurückgegeben und von dort  wieder an das Spiel geschickt wird.

\section{Erweiterung durch den Aufbau von Städten}
\label{sec:Staedte}
Beim Einpflegen von Städten in das Spiel handelt es sich um eine Erweiterung, die zwar zu den Muss-Anforderungen gehört, aber nicht in der initialen Beschreibung der Implementation enthalten war. Hier wurde sich zunächst nur auf den fundamentalen Aufbau des Spiels fokussiert. In dieser inbegriffen waren lediglich folgende Bestandteile: Straßen, Siedlungen, Spielzüge, die Funktion des Würfelns und die Ermittlung des Gewinners. Durch die Einführung der Städte in das Spiel erhöht sich die Komplexität für die Spieler ? sowohl für computergesteuerte als auch für menschliche. Entsprechend erhöht sich der strategische Anspruch an die Spieler, denn für den Fall, dass sowohl Siedlungen als auch Straßen und Städte gebaut werden können, aber nicht alle, muss eine Auswahl getroffen werden.

Die Implementierung der Städte ist sehr ähnlich zu der der Siedlungen. Einige Aspekte für Siedlungen wurden analog zu denen von Städten umgesetzt, weshalb eine erneute Auflistung des Quellcodes an dieser Stelle keinen Mehrwert bietet. 

Städte können auf Siedlungen errichtet werden: Sie stellen gewissermaßen ein Upgrade für diese dar. Für Straßen und Siedlungen geeignete Bauplätze wurden manuell als \textit{GameObjects} auf der Spielfläche platziert. Diese konnten nach Aktivierung des entsprechenden Baumenüs durch den Spieler ausgewählt werden. Wurde ein Bauplatz angeklickt, so entstand dort eine Straße oder eine Siedlung. Für die KI wurde dies durch
 
entsprechende Anfragen über die Schnittstelle realisiert. Auf gleiche Weise soll dies für die Städte bewerkstelligt werden. Der große Unterschied hinsichtlich der Bauplätze besteht in dem Zeitpunkt ihrer Erstellung: Die Bauplätze von Straßen und Siedlungen sind bereits vor Beginn einer Partie im Spiel vorhanden und lediglich deaktiviert, bis sie zum Einsatz kommen. Dies ist für Städte nicht möglich. Ihre Bauplätze entstehen erst dann, wenn eine Siedlung gebaut wird, da sie an den gleichen Stellen wie die Siedlung errichtet werden. Hierzu wird wie bisher der Siedlungsbauplatz unter einer neuen Siedlung gelöscht und aus dem Spiel entfernt. Nun wird zusätzlich ein neuer Bauplatz für Städte erstellt und unter der Siedlung platziert. Dieser neue Bauplatz verfügt über die gleichen Eigenschaften wie ein Bauplatz für eine Siedlung, nur dass er diesmal für Städte gilt. Listing \ref{lst:GameManagerCityBuildPlace} zeigt, wie das Erzeugen eines Bauplatzes für Städte in den \textit{Gamemanager} integriert wird. In Listing \ref{lst:GameManager2} ist in den Zeilen 12-15 und 33-36 zu sehen, welcher Code konkret ersetzt bzw. erweitert wurde.
\\
\lstinputlisting[label=lst:GameManagerCityBuildPlace,caption={GameManager: Erstellung des Bauplatzes für Städte}]{Listings/GameManagerCityBuildPlace.cs}

Im nächsten Schritt gilt es, den Zugriff auf den erzeugten Bauplatz abzuspeichern, damit dieser auch ansteuerbar bleibt. Dies geschieht direkt in Form einer Liste im \textit{GameManager}. Außerdem wird eine Liste der Bauplätze für Städte in der Klasse \textit{Map} aktualisiert, sodass auch dort Zugriff besteht. Dieser Zugriff gilt im \textit{GameManager} für das \textit{GameObject}, während die \textit{Map} nur auf die abstrakte Repräsentation des Bauplatzes zugreifen kann. Zu sehen ist dieser Vorgang in Listing \ref{lst:GameManagerCityBuildPlace}. Der Zugriff erfolgt äquivalent zu dem auf Straßen oder Siedlungen.

Neben dem Zugriff müssen auch die Aktivierung und der Bau von Städten ermöglicht werden. Hierzu hat der Städtebauplatz ein passendes OnClick-Event, welches an dem OnClick-Event für Siedlungen orientiert ist. Es lässt sich ebenfalls durch eine geeignete Anweisung der KI aufrufen, welche der Schnittstelle als Option hinzugefügt wurde. Beim Erstellen des Städtebauplatzes erhielt dieser neben einer Position auch Informationen über die Felder, an denen er sich befindet. Diese gehen beim Bau der Stadt auf diese über, sodass nach dem Würfeln anhand dieser Informationen die Ressourcenverteilung für die Städte bestimmt werden kann. Es bleibt zu erwähnen, dass eine Stadt doppelt so viele Ressourcen bringt wie eine Siedlung. Sie erwirtschaftet in gewisser Weise die Erträge der Siedlung und zusätzlich noch ihre eigenen. Die Siedlung wird beim Bau einer Stadt aus dem Spiel entfernt, was auch für den jeweiligen Bauplatz gilt. Dies geschieht in der \textit{CityBuild}-Klasse, die äquivalent zur Version dieser Klasse für den Bau von Siedlungen aufgebaut ist, aber zudem die Löschung des Bauplatzes aus dem Spiel und der Löschung aus der Listen umsetzt (siehe Listing \ref{lst:BuildCity}).
\\
\lstinputlisting[label=lst:BuildCity,caption={Erzeugen einer Stadt im OnClick-Event des Bauplatzes}]{Listings/BuildCityOnMouseDown.cs}

Abgesehen vo einem höheren Ressourcenertrag verfügen Städte über die gleichen Eigenschaften wie Siedlungen. Zwischen ihnen müssen sich jeweils mindestens zwei Straßen befinden, was durch den Aufbau auf ehemaligen Siedlungen garantiert wird. Außerdem können um sie herum Straßen errichtet werden. Es gibt für Städte allerdings kein weiteres Upgrade, sodass eine einmal errichtete Stadt also an dieser Position bestehen bleibt, bis das Spiel beendet ist. Des Weiteren erhalten die Spieler je zwei Siegpunkte für jede ihrer Städte.

Neben dem Spiel selbst musste auch die Schnittstelle an die Implementation der Städte angepasst werden. Wichtig war dabei, eine zusätzliche Aktion einzuführen, die das Aktivieren des Baumodus für Städte und deren Bau ermöglicht. Hierzu wurden für die Städte die gleichen Mechanismen wie für Straßen und Siedlungen implementiert. Entsprechend kann die KI eine Aktion auswählen, die die Bauplätze sichtbar macht und so einen Bauplatz als Ziel auswählen. Auf diesem ausgewählten Platz wird anschließend eine Stadt errichtet. Gleiches wurde auf Seiten des Spiels aufgesetzt, damit entsprechende Anfragen auch von diesem verstanden werden. Dazu wurde die Klasse \textit{Plan} erweitert (siehe \ref{lst:Plan2}), sodass sie jetzt die genannten Aktionen erkennen und der entsprechenden Liste hinzufügen kann. Im \textit{PlayerScript} erfolgt die Verarbeitung dieser Liste. Hier wird, sofern die Voraussetzungen dafür erfüllt sind, entweder der Baumodus aktiviert oder eine Stadt errichtet (siehe \ref{lst:PlayerScriptCityActions}).
\\
\lstinputlisting[label=lst:Plan2,caption={Plan: Übersetzung des Strings in Aktionen über Städte}]{Listings/Plan2.cs}

\lstinputlisting[label=lst:PlayerScriptCityActions,caption={PlayerScript: Umsetzung der Aktionen durch die KI für Städte}]{Listings/PlayerScriptCityActions.cs}

Durch die erhöhte Komplexität sind beim Testen des Spielentwurfes neue Fehler aufgetreten: Beispielsweise kam es zu dem Problem, dass die verwendete KI für einige Spielsituationen keine Lösung wusste. Trat so ein Fall auf, wurde eine leere Antwort verschickt. Diese konnte das Spiel jedoch nicht verarbeiten, sodass eine \textit{Exception} geworfen wurde. Diese wird nun abgefangen. Die KI erhält in einem solchen Fall drei Versuche, eine sinnvolle Antwort zu liefern. Ist sie dazu nicht in der Lage bzw. tut sie dies nicht,  wechselt der Spieler und der Zug des aktuellen Spielers gilt als beendet. Zusätzlich dazu erfolgt das Abfangen der geworfenen \textit{Exception} über einen \textit{try-catch}-Block im \textit{JsonParser}, der die Bearbeitung einer leeren Antwort verhindert. Der \textit{JsonParser} liefert lediglich ein leeres Objekt T zurück, sollte der geschilderte Fall eintreten. Ein weiteres Problem stellte die Auswahl des Bauplatzes dar: Die KI war nicht wirklich in der Lage dazu, auszuwählen, wo eine Stadt, eine Siedlung oder eine Straße errichtet werden sollte. Diese Schwierigkeit konnte dadurch gelöst werden, dass der Situationsbeschreibung Informationen zu den Positionen alle Bauplätze hinzugefügt wurden, sodass die KI basierend auf diesen Informationen eine Auswahl treffen kann. In dem String, der die durchzuführenden Aktionen enthält, sind Zeile und Spalte der Bauplätze durch einen Doppelpunkt getrennt angegeben, und werden für alle drei Arten von Gebäuden auf gleiche Weise verarbeitet. Für Städte ist dies in Listing \ref{lst:Plan2} zu sehen;  für Straßen und Siedlungen erfolgt die Verarbeitung analog hierzu.
\\
\lstinputlisting[label=lst:PlayerScriptCityActions,caption={PlayerScript: Umsetzung der Aktionen durch die KI für Städte}]{Listings/PlayerScriptCityActions.cs}

\section{Initiale KIs}
\label{sec:InitialeKI}
Die initialen KIs wurden auf Seite der Schnittstelle implementiert und dementsprechend in Java umgesetzt. Das hat den Hintergrund, dass die KIs im späteren Verlauf fallbasiert vorgehen sollen und auf Basis bereits bekannter Fälle Lösungen für Situationen finden sollen.

Zunächst wurde der Aspekt der Fallbasiertheit jedoch vernachlässigt und seitens der Computerspieler mit festgelegten Reaktionen gearbeitet. Auf diese Weise wurden die Funktionalitäten geprüft und etwaige Fehler behoben. Dies erwies sich besonders während des Einpflegens neuer Funktionalitäten in das Spiel als hilfreich, da so eine Testumgebung zur Verfügung stand. Zudem musste so nicht mehr jeder Test manuell durchgeführt werden, was Zeit einsparte.

Die festgelegten Züge wurden in \quotes{den ersten Zug}, \quotes{den zweiten Zug} und \quotes{die übrigen Züge} unterteilt, wobei der erste und der zweite Zug sich stark ähnelten und sich entsprechend nur die übrigen Züge unterschieden. Wie ein normaler Zug durchgeführt wurde, ist in Listing \ref{lst:PlayerPlanErstellungTest} zu sehen. Zu erkennen ist, dass jede auszuführende Aktion durch eine passend benannte Methode repräsentiert wird. Jede dieser Methoden fügt dem Plan, der zurück ans Spiel geschickt wird, eine geeignete Aktion in Form eines Strings hinzu. Dieser String kann anschließend auf Seiten des Spiels wie in Abschnitt \ref{sec:Schnittstelle} und \ref{sec:Staedte} interpretiert werden.
\\
\lstinputlisting[label=lst:PlayerPlanErstellungTest,caption={Java-Klasse Player: Erstellen eines normalen Zuges zum Testen}]{Listings/PlayerPlanErstellen.java}

Neben dem Hinzufügen der Aktionen zum Plan verdeutlicht Listing \ref{lst:PlayerPlanErstellungTest} ebenfalls, wie verschiedene Aktionen zum Testen priorisiert werden: Ist der Bau einer Stadt möglich, so wird sie immer gebaut. Kann keine Stadt, aber eine Siedlung gebaut werden, so wählt die KI diese Option. Falls auch dies nicht möglich ist, weil zu wenige Ressourcen gesammelt wurden oder kein passender Bauplatz verfügbar ist, so versucht die KI, eine Straße zu bauen. Ist auch der Bau einer Straße ist nicht möglich, wird der Zug beendet.

Es kann jedoch auch vorkommen, dass die KI keine Antwort auf eine vorliegende Situation findet. Dann schickt sie einen leeren Plan an das Spiel zurück, worauf so reagiert wird, dass nach drei ungültigen Antworten eines Spielers automatisch der nächste am Zug ist.

Soviel zu den bisher festgelegten Reaktionen der KIs. Darüber hinaus soll auch die Fallbasiertheit in die Entwicklung einbezogen werden, was die KIs aufwertet und gleichzeitig für die Erfüllung der Kann-Anforderung \quotes{Das Spiel kann über initiale KIs} verfügen. sorgt. Hierzu muss eine Umstellung der Reaktionen der KIs erfolgen: Es reicht nicht mehr, über Verzweigungen Reaktionen zu erzeugen. Stattdessen ist nun das Vorhandensein einer Wissensbasis nötig, auf die zurückgegriffen werden kann, um mit ihrer Hilfe Pläne generieren zu können.
\\
\lstinputlisting[label=lst:DefaultCasesBeispiel,caption={Java-Klasse DefaultCases: Beispiel}]{Listings/DefaultCasesBeispiel.java}

Für die Erstellung der Wissensbasis dient die Klasse \textit{DefaultCases}, die in Java geschrieben wurde und grundlegende Fälle enthält, um der KI Intelligenz zu verleihen. Hierzu wird auf den Status eines Spielers zugegriffen, der alle wichtigen Attribute enthält. Es werden Fälle für jede grundlegende Situation erstellt. Ein Beispielfall ist hierfür in Listing \ref{lst:DefaultCasesBeispiel} zu sehen: Dieser Fall beschreibt, wie vorgegangen wird, wenn im ersten Zug bereits die Bauplätze für Siedlungen aktiviert wurden und nun der Bau einer solchen erfolgen soll. Dieser Fall steht stellvertretend für alle anderen, da alle Fälle auf gleiche Weise aufgebaut sind und sich nur in der Ausprägung der Attribute unterscheiden.

Die initialen Fälle dienen dazu, die Voraussetzungen für einen Plan festzuhalten. Das Ziel besteht darin, einen Plan nur dann auszuführen, wenn das Spiel dies auch zulässt. Durch die Standardfälle wird die bereits festgelegte Folge an Reaktionen aus Listing \ref{lst:PlayerPlanErstellungTest} simuliert. Der Unterschied zu festgelegten Reaktionen besteht allerdings darin, dass nun ganz einfach neue Fälle hinzukommen können, die die Wissensbasis erweitern und so die Performanz der KI erhöhen. 

Zum aktuellen Stand der Implementation würde das Hinzufügen speziellerer Fälle allerdings keinen Effekt erzielen, da zuvor auf die Wissensbasis zugegriffen werden muss, wozu die tatsächlichen Situationen mit den Fällen abgeglichen werden müssen, sodass anschließend anhand der wichtigen Attributen der Plan ausgewählt werden kann. Bei der Implementation dieses Prozesses, die nachfolgend erläutert wird, wurde sich eng an der Vorgehensweise von Hillmann \cite[vgl.]{Hillmann2017} orientiert.

In der Klasse \textit{CBREngine} läuft das \textit{Retrieval}. Es werden alle Attribute des Status der aktuellen Situation genutzt, um diesen als Input in die Fallbasis geben zu können und so einen möglichst ähnlich Fall zu finden. Ein gefundener Fall enthält immer einen Plan, der auf Validität überprüft und ggf. an das Spiel geschickt wird.

In diesem Schritt kann auch die Intelligenz einer KI beeinflusst werden. Zum Bau von Siedlungen kann eine präferierte Ressource angegeben werden. Dies wird in das \textit{Retrieval} einbezogen. Als Ergebnis kann ein Plan entstehen, der die Suche nach einem Bauplatz mit Zugang zu einer bestimmten Ressource anweist.

Eine mögliche Strategie wäre es, besetzte Ressourcenfelder möglichst auszureizen und dadurch mit wenig Platz auf der Karte viele Siegpunkte zu erwirtschaften. Hierzu sollten möglichst wenig Straßen zwischen zwei Städten bzw. Siedlungen existieren und vorhandene Siedlungen sollten schnellstmöglich zu Städten ausgebaut werden. Bei dieser Strategie ist das Priorisieren von Holz und Lehm zu Beginn des Spiels wichtig, um Momentum im Spiel aufzubauen. Allerdings erscheint es sinnvoll,  im späteren Spielverlauf aufgrund der hohen Kosten für den Bau von Städten vermehrt Wert auf Getreide und Stein gelegt werden.
 %Die Implementation ist in Listing \ref{lst:KIKonfigurationSpieler1} zu sehen. 

%\lstinputlisting[label=lst:KIKonfigurationSpieler1,caption={Java-Klasse CBREngine: Konfiguration KI-Spieler1}]{Listings/KIKonfigurationSpieler1(2).java}

Eine konträre Strategie für \textit{Spieler 2} zu finden, sollte für einen besonders interessanten Vergleich zwischen beiden Spielern sorgen. Daher soll \textit{Spieler 2} sich darauf konzentrieren, möglichst viel Kontrolle über das Spielfeld zu erhalten. Hierzu muss \textit{Spieler 2} viele Straßen und Siedlungen bauen, damit sie einen großen Anteil der potenziell verfügbaren Bauplätze einnehmen kann. Der Bau von Städten ist bei dieser Strategie hingegen eher zu vernachlässigen; es sei denn, die KI kann dadurch ihr Ressourceneinkommen signifikant steigern. Außerdem sollte \textit{Spieler 2} sich vor allem auf den Gewinn der Ressourcen Lehm und Holz konzentrieren, da beide Rohstoffe sowohl für Straßen als auch für Siedlungen benötigt werden. Allerdings muss besonders zu Beginn des Spiels ebenfalls auf den Zugang zu Getreide und Schafen geachtet werden, da eine Expansion auf der Spielfläche, die den Gegner einschränkt, ohne diese gar nicht möglich wäre. \\
Nachdem \textit{Spieler 2} dementsprechend hinsichtlich der ersten beiden Züge die gleichen Präferenzen hat wie \textit{Spieler 1}, unterscheidet sich das Vorgehen der beiden Spieler hinsichtlich der gewöhnlichen Zügen. Wenn nicht gewürfelt werden darf, kommt die jeweilige Strategie des Spielers zum Tragen. Beim Bau von Siedlungen werden nicht allein Stein und Getreide priorisiert, sondern zudem in ausgeglichener Form Holz, Lehm, Schafe und Getreide.

Eine interessante Erweiterung für eine weitere Strategie wäre die Kombination beider Herangehensweisen: Statt einer einfachen Priorisierung könnte die Berücksichtigung der Überlegung einbezogen werden, welcher Schritt für die kommenden Runden den größten Ressourcenertrag verspricht. Die auf Städte konzentrierte KI würde Steine und Weizen priorisieren, die auf Expansion gerichtete KI eher Lehm und Holz. Eine KI, die keine klare Präferenz an Gebäuden hat, könnte möglicherweise mehr Siegpunkte erlangen, da ihre Wahl an die Situation angepasst würde.

Damit die beschriebene Strategie auch umgesetzt werden kann, müssen priorisierte Ressourcen in die Implementation eingebracht werden. Hierzu werden die einzelnen Fälle um das Attribut \textit{preference} erweitert. Dieses Attribut erlaubt es, eine priorisierte Ressource mit in das \textit{Retrieval} einfließen zu lassen, wodurch letztlich eine bessere Entscheidung getroffen werden kann. Die Priorisierung von Ressourcen ist überall dort Teil der Standardfälle, die den Bau einer neuen Siedlungen als Plan enthalten.

Zur Umsetzung zweier verschiedener Strategien muss eine getrennte Berechnung der Präferenzen erfolgen. Diese wird direkt in der Java-Klasse Status vorgenommen. Diese wurde um zwei Methoden mit den Namen \textit{CalculatePreferencePlayer1} und \textit{CalculatePreferencePlayer2} erweitert. In Listing \ref{lst:CalculatePreferencePlayer2} ist allerdings nur die zweite dieser beiden Methoden abgebildet, die zweite Methode ist im Anhang zu finden. Allerdings reicht zum Verständnis die Betrachtung einer der beiden Methoden, da beide ähnlich vorgehen: Auf Basis der vorhandenen Mengen an Ressourcen wird eine Präferenz berechnet. Dabei wird zunächst zwischen dem ersten Zug, dem zweiten Zug und den übrigen Zügen unterschieden, da für beide Spieler gilt: Sie bauen im ersten Zug die kostenlose Siedlung an einem Ressourcenfeld, welches Holz liefert, während sie im zweiten Zug an einem Feld bauen, welches Lehm liefert. Dies ist deshalb entscheidend, weil zum aktuell implementierten Stand des Spiels kein späteres Tauschen möglich ist. Entsprechend sollten die KIs versuchen, schnellstmöglich Zugang zu den für sie wichtigen Ressourcen zu erhalten. Da Holz und Lehm sowohl für Siedlungen als auch für Straßen benötigt werden, fokussieren sich die Spieler zunächst auf diese.

Anschließend an die ersten beiden Züge wird jedoch  langsam die Strategie des jeweiligen Spielers deutlich. Die gezeigte Methode setzt immer dann, wenn der Bau einer Siedlung möglich ist, diejenige Ressource als Präferenz, die am wenigsten zur Verfügung steht. Sollten allerdings zwei Ressourcen gleich häufig verfügbar sein, so wird die wichtigere für den Bau von Straßen und Siedlungen (meist Holz oder Lehm) gewählt. Wenn die Entscheidung zwischen Getreide und Schafen getroffen werden muss, dann ist das Getreide vorzuziehen. Stein wird nie präferiert, da dieser zur Expansion nicht entscheidend ist und weder zum Bau von Siedlungen noch zum Bau von Straßen gebraucht wird. \textit{Spieler 1} präferiert ? mit Ausnahme der ersten beiden Züge - nie Holz oder Lehm.

Die Berechnung der Präferenzen wurde in der obigen Erklärung erläutert. Eine solche findet auf ähnliche Weise auch für \textit{Spieler 1} statt, der in normalen Zügen allerdings immer Getreide oder Stein präferiert, was ihn sehr anfällig für Fehler macht.
\\
\lstinputlisting[label=lst:CalculatePreferencePlayer2,caption={Java-Klasse Status: CalculatePreferencePlayer2}]{Listings/CalculatePreferencePlayer2.java}

\section{Bug-Fixes}
Während der Entwicklung der Software traten mehrere Bugs auf, die es zu lösen galt. Einige dieser Bugs wurden bereits in anderen Abschnitten dieses Kapitels kurz angesprochen. Nachfolgend sollen diese allerdings nochmals aufgelistet und ihr Auftreten sowie ihre Lösung detaillierter besprochen werden.

Der erste Bug zeigte sich beim Generieren des Spielfelds, womit u.a. erreicht werden soll, dass einem Feld des Typus Wüste keine Zahl zugeordnet wird. Dies wird erreicht, solange die Wüste nicht direkt in der Mitte des Spielfeldes liegt, davor der Generierung zunächst Prefabs auf jedem einzelnen Feld platziert werden, die später befüllt und im Falle der Wüste gelöscht werden. Liegt die Wüste allerdings in der Mitte des Spielfeldes, so wird der Prefab nicht befüllt, aber auch nicht gelöscht. Dieser Bug ist deshalb nicht gravierend, weil er das Spielgeschehen an sich nicht beeinflusst. Da er nicht gelöst wurde, wird er erneut im Ausblick (siehe Abschnitt \ref{sec:Ausblick}) aufgegriffen.

Zudem existierte der Bug, dass die erste Siedlung eines Spielers nicht durch einen Bauplatz für Städte ergänzt wurde. Dieser Bug trat allerdings nur bei KI-Spielern auf. Der Grund für das Auftreten dieses Bugs schien an der Geschwindigkeit der Abfrage zu liegen. Offensichtlich wurde nach der Ausführung des bestehenden Plans so schnell eine neue Anfrage gesendet, dass der Bauplatz noch nicht erstellt wurde. Dieses Problem konnte gelöst werden, indem der Abschnitt des \textit{Gamemanagers} - welcher die umliegenden Siedlungsbauplätze löscht und den Städtebauplatz erzeugt - nach dem Bau einer Siedlung in die Klasse \textit{buildVillage} verlegt  wurde.

Ein weiterer Bug entstand durch das Zusammenspiel von Spiel und KI über die Schnittstelle: Hierbei zeigte sich, dass die KI in einigen Fällen eine leere Antwort lieferte. Da das Weiterspielen in diesen Fällen unmöglich war, wurde der Bug auf zweifache Weise gelöst. Zunächst fängt eine entsprechende Exception den Fehler auf Seiten des Spiels ab und erlaubt der KI noch zwei weitere Versuche. Des Weiteren wird durch die Schnittstelle nun in jedem Fall ein Plan zur Antwort hinzugefügt. Dieser Plan besteht im Zweifelsfall daraus, einen Zug zu beenden oder zu Würfeln ? abhängig davon, welcher Zustand gerade herrscht.

Außerdem kam es vor, dass die KI teilweise unfaähig zu entscheiden war, welcher Fall am ehesten auf die jeweilige Situation passte. Sie fand in einigen Fällen keine Lösung und lieferte nahezu identische Ähnlichkeitswerte. Dieses Problem konnte durch eine Erweiterung der Fallbasis um zusätzliche Fälle sowie eine Anpassung der bestehenden Fälle gelöst werden. Zudem schien die Gewichtung einzelner Symptome mehr Nachteile als Vorteile mit sich zu bringen, weshalb dieser Schritt aus dem \textit{Retrieval} entfernt wurde.

Ein letzter Bug, der hier erwähnt werden soll, trat auf, wenn menschliche Spieler versuchten, während der ersten beiden Züge zusätzlich zu den kostenlosen Objekten weitere Straßen, Siedlungen oder Städte  zu bauen. Diese Aktion muss ihnen verboten werden, da es auch KI-Spielern untersagt ist, und der Grundsatz der Fairness gelten soll. Der Plan einer KI wird ein erstes Mal beim Erstellen und ein zweites Mal vor seiner Ausführung überprüft. Außerdem wird die Ausführung eines Plan über die gleichen Methoden wie bei einem menschlichen Spieler gesteuert. Das bedeutet, wenn die KI maximal die gleichen Züge wie ein Mensch durchführen kann, so beschränken die zwei Überprüfungen die KI zusätzlich, sofern diese nicht genauso oder weniger eng wie die für den menschlichen Spieler gefasst sind. Somit musste die Einhaltung der Regeln in den Bedingungen zur Ausführung eines Zuges angepasst werden: Es musste dafür gesorgt werden, dass einige Optionen nur, andere gerade nicht in den ersten beiden Zügen erlaubt sind. Dies wurde hauptsächlich innerhalb der Update-Methode realisiert, die für solche Überprüfungen zur Verfügung steht.

\section{Anpassungen}
Nachdem im Kapitel \ref{cha:Entwurf} die Planung der Implementierung beschrieben wurde, dient dieses Kapitel der Erläuterung der Umsetzung. Hierbei ergaben sich teilweise große Diskrepanzen zwischen der Planung und der Realisierung, weshalb dieser Abschnitt auf diese Unterschiede eingehen und erläutern soll, weshalb sich teilweise gegen die ursprüngliche Konzeption entschieden wurde.

\subsection{Anpassungen am Spiel}
Im Vergleich zum Entwurf wurden in der Implementation des Spiels nur wenige Änderungen vorgenommen. So erfolgte beispielsweise der Aufbau des Spielfelds wie geplant. Dieser berücksichtigt alle Aspekte, die im Entwurf geschildert wurden, und dessen Implementation wird im  Abschnitt \ref{sec:Spiel} detailliert erläutert. Des Weiteren sind die ersten beiden Züge und das übrige Spiel nach Maßgabe der Konzeption gestaltet. Damit das Spiel gewonnen werden kann, wurden ? wie geplant - 10 Siegpunkte als Standardeinstellung festgelegt. 

Es wurden lediglich kleinere Details vernachlässigt, was eng mit den Kann- bzw. Soll-Anforderungen verknüpft ist. So ist der Handel kein Teil des gewöhnlichen Spielzuges und Errungenschaften wie \textit{die größte Rittermacht} können nicht zum Sieg beitragen, da keine Ereigniskarten zur Verfügung stehen. Des Weiteren wurde auch der Räuber nicht im Spiel umgesetzt. Davon abgesehen entspricht das Spiel dem Entwurf. Lediglich auf einen zusätzlichen Aspekt, der in der Implementation bereits beschriebenen wurde, soll an dieser Stelle noch hingewiesen werden. So wird im Regelwerk des Spiels\textit{ Siedler von Catan} (s. Anhang) beschrieben, dass die in den ersten beiden Zügen kostenlos gebaute Straßen nur an derjenigen Siedlung angebaut werden können, die im jeweiligen Zug errichtet wurde. Dieser Aspekt wurde nicht in die Implementierung einbezogen.

\subsection{Anpassungen an der Schnittstelle}
Die Schnittstelle bzw. die Kommunikation zwischen Spiel und KI ist der Teil der Implementation, der die größte Diskrepanz zum Entwurf aufweist. Es wurde zunächst geplant, dass unterschiedliche Nachrichten über die Schnittstelle hin und her geschickt werden. Hierbei wurde häufig die KI als der Initiator einer Nachricht genannt und geplant, dass das Spiel antworten und der KI die nötigen Informationen auf Anfrage bereitstellen würde. Dieses Konzept wurde nicht angewandt, sondern durch ein simpleres ersetzt, welches die Anforderungen im gleichen Umfang erfüllt.

In der aktuellen Umsetzung agiert die Schnittstelle auf Seiten der KI als Anfragen verarbeitender Server. Dieser Server hat einen Client: das Spiel. Dementsprechend sendet das Spiel seine Anfragen an die Schnittstelle und nicht die Schnittstelle an das Spiel. Eine Anfrage besteht dabei aus der Situation, die alle nötigen Informationen enthält. Serverseitig kann daraufhin eine Antwort generiert werden. Diese Antwort ist so aufgebaut wie die Anfrage, jedoch enthält sie zusätzlich einen Plan, welcher  vom Spiel empfangen und ggf. verarbeitet wird.

Dieses Vorgehen bedarf weniger Komplexität in der Kommunikation. Es muss lediglich eine Art von Nachricht versendet bzw. empfangen und verarbeitet werden. Das Nachrichtenformat ist dabei für alle Zustände des Spiels identisch. Auch die Zeitpunkte, zu denen Kommunikation erfolgt, konnten reduziert werden. Ein Spieler erhält nur dann Informationen, wenn er am Zug ist und kann daraufhin einen Plan ausarbeiten. Wenn dieser Plan ausgeführt wurde und der Zug des jeweiligen Spielers noch nicht beendet ist, wird eine erneute Anfrage gestellt, die wieder vom Spieler mit einem Plan beantwortet wird. Dieses Frage-Antwort-Prozedere wird so lange fortgesetzt, bis der Spieler seinen Zug beendet oder das Beenden des Zuges durch das Spiel selbst eingeleitet wird. Anschließend an die Zugbeendung wird eine neue Kommunikation mit dem nächsten Spieler eingeleitet. Welcher Spieler jeweils Informationen erhält, ist in der Situationsbeschreibung enthalten und wird serverseitig ausgewertet. Abhängig vom Spieler können so Nuancen hinsichtlich der Strategie festgelegt werden.

Das beschriebene Verfahren erfüllt die gestellten Anforderungen auch weiterhin. Ein Aspekt, den es besonders zu bedenken gilt, ist der der Fairness. Dieser behält auch durch das eingesetzte Verfahren Bestand, da mit der Situationsbeschreibung zwar das Spielgeschehen übermittelt wird, dabei den KIs aber keine Informationen geliefert werden, auf die ein menschlicher Spieler nicht auch Zugriff hätte.